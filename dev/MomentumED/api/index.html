<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Reference · MomentumED.jl</title><meta name="title" content="API Reference · MomentumED.jl"/><meta property="og:title" content="API Reference · MomentumED.jl"/><meta property="twitter:title" content="API Reference · MomentumED.jl"/><meta name="description" content="Documentation for MomentumED.jl."/><meta property="og:description" content="Documentation for MomentumED.jl."/><meta property="twitter:description" content="Documentation for MomentumED.jl."/><meta property="og:url" content="https://Zou-Bo.github.io/MomentumED.jl/MomentumED/api/"/><meta property="twitter:url" content="https://Zou-Bo.github.io/MomentumED.jl/MomentumED/api/"/><link rel="canonical" href="https://Zou-Bo.github.io/MomentumED.jl/MomentumED/api/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">MomentumED.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">EDCore</span><ul><li><a class="tocitem" href="../../EDCore/api/">API Reference</a></li></ul></li><li><span class="tocitem">MomentumED</span><ul><li class="is-active"><a class="tocitem" href>API Reference</a><ul class="internal"><li><a class="tocitem" href="#Main-EDsolve-Function"><span>Main EDsolve Function</span></a></li><li><a class="tocitem" href="#Preparation"><span>Preparation</span></a></li><li><a class="tocitem" href="#Methods"><span>Methods</span></a></li><li><a class="tocitem" href="#Analysis"><span>Analysis</span></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">MomentumED</a></li><li class="is-active"><a href>API Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/Zou-Bo/MomentumED.jl/blob/main/docs/src/MomentumED/api.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="MomentumED-API-Reference"><a class="docs-heading-anchor" href="#MomentumED-API-Reference">MomentumED API Reference</a><a id="MomentumED-API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#MomentumED-API-Reference" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MomentumED" href="#MomentumED"><code>MomentumED</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>This module gives general methods for 2D momentum-block-diagonalized ED calculations. Sectors of other quantum Numbers should be handled outside this module. This module only sets sectors of total (crystal) momentum, also called blocks.</p><p><strong>export list</strong></p><pre><code class="language-julia hljs"># submodules
export EDCore
public Preparation, Methods, Analysis

# main solving function
export EDsolve

# from EDCore
export MBS64, NormalScatter, MBOperator
export HilbertSubspace, MBS64Vector, Scatter
public get_bits, get_body, make_dict!, delete_dict!
public isphysical, isupper, isnormal, isnormalupper, isdiagonal
export ED_bracket, ED_bracket_threaded
public ColexMBS64, ColexMBS64Mask

# preparation
export EDPara, ED_momentum_subspaces
export ED_sortedScatterList_onebody
export ED_sortedScatterList_twobody

# methods
public ED_HamiltonianMatrix_threaded, LinearMap

# analysis - reduced density matrix for entanglement spectrum
export PES_1rdm, PES_MomtBlocks, PES_MomtBlock_rdm
export OES_NumMomtBlocks, OES_NumMomtBlock_coef

# analysis - many-body connection
export ED_connection_step, ED_connection_gaugefixing!

# environment variables
public PRINT_RECURSIVE_MOMENTUM_DIVISION
public PRINT_TWOBODY_SCATTER_PAIRS</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zou-Bo/MomentumED.jl/blob/e69db134d5297dd85a3020ba2ceb80e32c146fc5/MomentumED/src/MomentumED.jl#L1-L42">source</a></section></article><h2 id="Main-EDsolve-Function"><a class="docs-heading-anchor" href="#Main-EDsolve-Function">Main EDsolve Function</a><a id="Main-EDsolve-Function-1"></a><a class="docs-heading-anchor-permalink" href="#Main-EDsolve-Function" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MomentumED.EDsolve" href="#MomentumED.EDsolve"><code>MomentumED.EDsolve</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">EDsolve(subspace::HilbertSubspace, hamiltonian; kwargs...) 
    -&gt; energies::Vector, vectors::Vector{MBS64Vector}</code></pre><p>Main exact diagonalization solver for momentum-conserved quantum systems.</p><p>This function finds the lowest eigenvalues and eigenvectors of a Hamiltonian within a given momentum subspace. It supports multiple methods for diagonalization and can accept the Hamiltonian in two formats.</p><p><strong>Arguments</strong></p><ul><li><code>subspace::HilbertSubspace</code>: The Hilbert subspace for a specific momentum block, containing the basis states.</li><li><code>hamiltonian</code>: The Hamiltonian to be diagonalized. It can be provided in two forms:<ol><li>As a series of sorted <code>Vector{&lt;:Scatter}</code> arguments (e.g., <code>EDsolve(subspace, scat1, scat2)</code>). This form is used for matrix-based methods.</li><li>As a single <code>MBOperator</code> object (e.g., <code>EDsolve(subspace, H_operator)</code>). This form is required for the matrix-free <code>:map</code> method.</li></ol></li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>N::Int64 = 6</code>: The number of eigenvalues/eigenvectors to compute.</li><li><code>method::Symbol = :sparse</code>: The diagonalization method. Options are:<ul><li><code>:sparse</code>: (Default) Constructs the Hamiltonian as a sparse matrix. Good for most cases.</li><li><code>:dense</code>: Constructs a dense matrix. Can be faster for very small systems.</li><li><code>:map</code>: Uses a matrix-free <code>LinearMap</code> approach. This is the most memory-efficient method for very large systems and requires the <code>hamiltonian</code> to be an <code>MBOperator</code>.</li></ul></li><li><code>element_type::Type = Float64</code>: The element type for the Hamiltonian matrix (for <code>:sparse</code>/:<code>dense</code>).</li><li><code>index_type::Type = Int64</code>: The integer type for the sparse matrix indices (for <code>:sparse</code>).</li><li><code>min_sparse_dim::Int64 = 100</code>: If <code>method</code> is <code>:sparse</code> but the dimension is smaller than this, it will automatically switch to <code>:dense</code>.</li><li><code>max_dense_dim::Int64 = 200</code>: If <code>method</code> is <code>:dense</code> but the dimension is larger than this, it will automatically switch to <code>:sparse</code>.</li><li><code>ishermitian::Bool = true</code>: Specifies if the Hamiltonian is Hermitian. This is passed to the eigensolver for optimization.</li><li><code>showtime::Bool = false</code>: If <code>true</code>, prints the time taken for matrix construction and diagonalization.</li><li><code>krylovkit_kwargs...</code>: Additional keyword arguments passed directly to <code>KrylovKit.eigsolve</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>energies::Vector</code>: A vector containing the <code>N</code> lowest eigenvalues.</li><li><code>vectors::Vector{MBS64Vector}</code>: A vector of the corresponding eigenvectors, wrapped in the <code>MBS64Vector</code> type.</li></ul><p><strong>Examples</strong></p><p><strong>1. Using Scatter Lists (Sparse Method):</strong></p><pre><code class="language-julia hljs">subspaces, _, _ = ED_momentum_subspaces(para, (1,1))
scat1 = ED_sortedScatterList_onebody(para)
scat2 = ED_sortedScatterList_twobody(para)

# Find the 2 lowest energy states
energies, vecs = EDsolve(subspaces[1], scat1, scat2; N=2, method=:sparse)</code></pre><p><strong>2. Using MBOperator (Linear Map Method):</strong></p><pre><code class="language-julia hljs">H_op = MBOperator(scat1, scat2)
# Find the 2 lowest energy states using the matrix-free approach
energies, vecs = EDsolve(subspaces[1], H_op; N=2, method=:map)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zou-Bo/MomentumED.jl/blob/e69db134d5297dd85a3020ba2ceb80e32c146fc5/MomentumED/src/MomentumED.jl#L125-L175">source</a></section></article><h2 id="Preparation"><a class="docs-heading-anchor" href="#Preparation">Preparation</a><a id="Preparation-1"></a><a class="docs-heading-anchor-permalink" href="#Preparation" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MomentumED.Preparation" href="#MomentumED.Preparation"><code>MomentumED.Preparation</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>This module provides methods of defining a system for calculation. Many functions assume the system has at most two-body symmetric interaction, Hermitian Hamiltonian, and momentum conservation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zou-Bo/MomentumED.jl/blob/e69db134d5297dd85a3020ba2ceb80e32c146fc5/MomentumED/src/MomentumED.jl#L87-L91">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MomentumED.Preparation.EDPara" href="#MomentumED.Preparation.EDPara"><code>MomentumED.Preparation.EDPara</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mutable struct EDPara</code></pre><p>Stores all parameters for a momentum-conserved exact diagonalization calculation.</p><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">EDPara(; 
    Gk::Tuple{Int64, Int64} = (0, 0), 
    k_list::Matrix{Int64},
    Nc_hopping::Int64 = 1,
    Nc_conserve::Int64 = 1,
    H_onebody::Array{ComplexF64,4} = zeros(ComplexF64, Nc_hopping, Nc_hopping, Nc_conserve, size(k_list, 2)),
    V_int::Function = (kf1, kf2, ki1, ki2, cf1, cf2, ci1, ci2) -&gt; 0.0 + 0.0im,
    FF_inf_angle::Function = (k_f, k_i, c) -&gt; 0.0
)</code></pre><p><strong>Keyword Arguments</strong></p><ul><li><code>k_list::Matrix{Int64}</code>: <strong>Required</strong>. A matrix where each column <code>k_list[:, i]</code> represents a momentum vector <code>(k_x, k_y)</code>.</li><li><code>Gk::Tuple{Int64, Int64} = (0, 0)</code>: The reciprocal lattice vectors <code>(G1, G2)</code>. Momentum is conserved modulo <code>Gk</code>. A value of <code>0</code> means no periodicity in that direction.</li><li><code>Nc_hopping::Int64 = 1</code>: The number of &quot;hopping&quot; components whose particle numbers are not conserved.</li><li><code>Nc_conserve::Int64 = 1</code>: The number of components where the particle number is conserved (e.g., valley).</li><li><code>H_onebody::Array{ComplexF64,4}</code>: The one-body part of the Hamiltonian. Defaults to zeros.</li><li><code>V_int::Function</code>: A function defining the two-body interaction potential. See &quot;Interaction Function&quot; below. Defaults to a function that returns zero.</li><li><code>FF_inf_angle::Function</code>: A function defining the Berry connection for infinitesimal transformations. See &quot;Berry Connection Function&quot; below. Defaults to a function that returns zero.</li></ul><p><strong>Fields (in addition to keyword arguments)</strong></p><ul><li><code>Nk::Int64</code>: The number of momentum states, derived from <code>size(k_list, 2)</code>.</li><li><code>Nc::Int64</code>: The total number of components, <code>Nc_hopping * Nc_conserve</code>.</li><li><code>momentum_coordinate::Bool</code>: A flag that is automatically set to <code>true</code> if <code>V_int</code> accepts momentum coordinates (<code>Tuple{Float64,Float64}</code>), and <code>false</code> if it accepts momentum indices (<code>Int64</code>).</li></ul><p><strong>Interaction Function (<code>V_int</code>)</strong></p><p>The <code>V_int</code> function must accept 8 arguments and return a <code>ComplexF64</code>.  <code>V_int(kf1, kf2, ki2, ki1, cf1::Int64, cf2::Int64, ci2::Int64, ci1::Int64)</code> -&gt; <code>ComplexF64</code>. Input momenta can have one of two signatures:</p><ol><li>Coordinate-based: <code>ki</code> and <code>kf</code> are momentum coordinates as <code>Tuple{&lt;:Real, &lt;:Real}</code>.</li><li>Index-based: <code>ki</code> and <code>kf</code> are momentum indices as <code>Int64</code>, refering to the momenta in <code>k_list</code>.</li></ol><p>The constructor automatically detects which signature is used.</p><p><strong>Berry Connection Function (<code>FF_inf_angle</code>)</strong></p><p>The <code>FF_inf_angle</code> function must accept 3 arguments <code>(k_f, k_i, c)</code> and return a <code>Float64</code>. <code>k_f</code> and <code>k_i</code> are momentum coordinates.</p><p><strong>Orbital Indexing</strong></p><p>The single orbital index <code>i</code> is mapped from a multi-index <code>(i_k, i_ch, i_cc)</code> as follows: <code>i = i_k + Nk * (i_ch - 1) + (Nk * Nc_hopping) * (i_cc - 1)</code> where <code>i_k</code> is the momentum index, <code>i_ch</code> is the hopping component index, and <code>i_cc</code> is the conserved component index.</p><p><strong>Validation</strong></p><ul><li>The total number of orbitals (<code>Nk * Nc</code>) must not exceed 64.</li><li>The provided <code>V_int</code> and <code>FF_inf_angle</code> functions must conform to one of the valid signatures.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zou-Bo/MomentumED.jl/blob/e69db134d5297dd85a3020ba2ceb80e32c146fc5/MomentumED/src/preparation/init_parameter.jl#L9-L59">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MomentumED.Preparation.ED_momentum_subspaces-Tuple{EDPara, Any}" href="#MomentumED.Preparation.ED_momentum_subspaces-Tuple{EDPara, Any}"><code>MomentumED.Preparation.ED_momentum_subspaces</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ED_momentum_subspaces(para::EDPara, N_each_component; kwargs...) -&gt; Tuple{Vector{HilbertSubspace}, Vector{Int64}, Vector{Int64}}</code></pre><p>Constructs Hilbert subspaces, each corresponding to a specific total momentum.</p><p>This is the main user-facing function to generate the basis states for a momentum-conserved calculation. It orchestrates the construction of many-body states by calling the recursive helper function <code>mbslist_recursive_iteration!</code>. The resulting states are partitioned into <code>HilbertSubspace</code> objects, each containing all states with a specific total momentum <code>(K1, K2)</code>.</p><p><strong>Arguments</strong></p><ul><li><code>para::EDPara</code>: The parameter object containing system details like momentum vectors and component info.</li><li><code>N_each_component</code>: A tuple or vector specifying the number of particles in each conserved component. The sign of the number has a special meaning:<ul><li><strong>Positive <code>N</code></strong>: Represents <code>N</code> particles.</li><li><strong>Negative <code>N</code></strong>: Represents <code>abs(N)</code> holes in a fully filled band. This is useful for certain calculations like the particle reduced density matrix (see <code>MomentumED/src/analysis/particle_reduced_density_matrix.jl</code>).</li></ul></li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>dict::Bool = false</code>: If <code>true</code>, a dictionary mapping each state to its index is created within each <code>HilbertSubspace</code>.</li><li><code>index_type::Type = Int64</code>: The integer type for the dictionary indices.</li><li><code>momentum_restriction::Bool = false</code>: If <code>true</code>, only generate subspaces for momenta specified by <code>k1range</code>, <code>k2range</code>, or <code>momentum_list</code>.</li><li><code>k1range::Tuple{Int64, Int64}</code>: The range of <code>k1</code> total momentum to generate.</li><li><code>k2range::Tuple{Int64, Int64}</code>: The range of <code>k2</code> total momentum to generate.</li><li><code>momentum_list::Vector{Tuple{Int64, Int64}}</code>: A list of specific <code>(K1, K2)</code> total momenta to generate.</li><li><code>mask::Union{Nothing, Vector{Int64}} = nothing</code>: Restricts the set of available single-particle orbitals for the first component processed by the recursive algorithm. For positive <code>N</code>, only orbitals in the mask are occupied. For negative <code>N</code>, holes are created only from orbitals in the mask.</li></ul><p><strong>Returns</strong></p><ul><li><code>subspaces::Vector{HilbertSubspace}</code>: A vector of Hilbert subspaces. Each element contains a list of <code>MBS64</code> states belonging to a specific momentum.</li><li><code>subspace_k1::Vector{Int64}</code>: A vector where <code>subspace_k1[i]</code> is the <code>k1</code> momentum of <code>subspaces[i]</code>.</li><li><code>subspace_k2::Vector{Int64}</code>: A vector where <code>subspace_k2[i]</code> is the <code>k2</code> momentum of <code>subspaces[i]</code>.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">para = EDPara(k_list=[0 1; 0 0], Nc_conserve=2)
# Generate subspaces for a system with 1 particle in the first component and 2 in the second
subspaces, subspace_k1, subspace_k2 = ED_momentum_subspaces(para, (1, 2))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zou-Bo/MomentumED.jl/blob/e69db134d5297dd85a3020ba2ceb80e32c146fc5/MomentumED/src/preparation/momentum_decomposition.jl#L162-L195">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MomentumED.Preparation.ED_sortedScatterList_onebody-Tuple{EDPara}" href="#MomentumED.Preparation.ED_sortedScatterList_onebody-Tuple{EDPara}"><code>MomentumED.Preparation.ED_sortedScatterList_onebody</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ED_sortedScatterList_onebody(para::EDPara) -&gt; Vector{Scatter{1}}</code></pre><p>Generate sorted lists of one-body Scatter terms from the parameters.</p><p>Extracts one-body terms from EDpara.H_onebody for multi-component systems and converts them to Scatter terms with proper normal ordering.</p><p><strong>Arguments</strong></p><ul><li><code>para::EDPara</code>: Parameter structure containing system configuration</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Scatter{1}}</code>: Sorted list of one-body Scatter terms</li></ul><p><strong>Details</strong></p><ul><li>Maps component indices to global orbital indices using: <code>global_index = k + Nk * (ch - 1) + Nk * Nch * (cc - 1)</code></li><li>Applies normal ordering to avoid double-counting</li><li>Uses <code>sort_merge_scatlist</code> to eliminate duplicates and sort terms</li><li>Only includes non-zero amplitude terms</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">para = EDPara(k_list=k_list, Gk=(3, 5), V_int=V_int)
Scatter1 = ED_sortedScatterList_onebody(para)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zou-Bo/MomentumED.jl/blob/e69db134d5297dd85a3020ba2ceb80e32c146fc5/MomentumED/src/preparation/scat_list.jl#L1-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MomentumED.Preparation.ED_sortedScatterList_twobody-Tuple{EDPara}" href="#MomentumED.Preparation.ED_sortedScatterList_twobody-Tuple{EDPara}"><code>MomentumED.Preparation.ED_sortedScatterList_twobody</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ED_sortedScatterList_twobody(para::EDPara; kshift=nothing) -&gt; Vector{Scatter{2}}</code></pre><p>Generate a sorted list of two-body <code>Scatter</code> terms from the interaction potential.</p><p>This function orchestrates the generation of all two-body scattering terms. It first groups momentum pairs by their total momentum to ensure conservation, then calls the appropriate internal function (<code>scat_pair_group_coordinate</code> or <code>scat_pair_group_index</code>) based on the signature of the interaction potential <code>para.V_int</code>.</p><p><strong>Arguments</strong></p><ul><li><code>para::EDPara</code>: The parameter structure containing system configuration, including the <code>V_int</code> function.</li></ul><p><strong>Keywords</strong></p><ul><li><code>kshift=nothing</code>: Specifies a momentum shift for twisted boundary conditions. This is only applicable if <code>para.V_int</code> accepts momentum coordinates. The value can be:<ul><li><code>nothing</code> (default): No shift.</li><li><code>Tuple{Real, Real}</code>: A uniform shift <code>(kx, ky)</code> applied to all conserved components.</li><li><code>Vector{Tuple{Real, Real}}</code>: A specific shift for each conserved component.</li><li><code>Matrix{Real}</code>: A <code>2 x Nc_conserve</code> matrix specifying the shift for each component.</li></ul></li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Scatter{2}}</code>: A sorted and merged list of all unique two-body <code>Scatter</code> terms.</li></ul><p><strong>Details</strong></p><ul><li>Automatically detects whether <code>para.V_int</code> uses momentum coordinates or indices.</li><li>If using indices, <code>kshift</code> is ignored.</li><li>The final list is processed by <code>sort_merge_scatlist</code> to eliminate duplicates and sort the terms.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">para = EDPara(k_list=k_list, Gk=(3, 5), V_int=V_int)
# Generate with no momentum shift
Scatter2 = ED_sortedScatterList_twobody(para)
# Generate with a uniform twisted boundary condition
Scatter2_shifted = ED_sortedScatterList_twobody(para; kshift=(0.1, 0.1))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zou-Bo/MomentumED.jl/blob/e69db134d5297dd85a3020ba2ceb80e32c146fc5/MomentumED/src/preparation/scat_list.jl#L313-L346">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MomentumED.Preparation.MBS_totalmomentum-Tuple{EDPara, Vararg{Int64}}" href="#MomentumED.Preparation.MBS_totalmomentum-Tuple{EDPara, Vararg{Int64}}"><code>MomentumED.Preparation.MBS_totalmomentum</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MBS_totalmomentum(para::EDPara, i_list::Int64...)</code></pre><p>Calculate the total momentum (K1, K2) from a list of occupied orbital indices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zou-Bo/MomentumED.jl/blob/e69db134d5297dd85a3020ba2ceb80e32c146fc5/MomentumED/src/preparation/momentum_decomposition.jl#L64-L68">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MomentumED.Preparation.MBS_totalmomentum-Tuple{Matrix{Int64}, Tuple{Int64, Int64}, MBS64}" href="#MomentumED.Preparation.MBS_totalmomentum-Tuple{Matrix{Int64}, Tuple{Int64, Int64}, MBS64}"><code>MomentumED.Preparation.MBS_totalmomentum</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MBS_totalmomentum(para::EDPara, mbs::MBS64)</code></pre><p>Calculate the total momentum (K1, K2) of a many-body state. The momentum is mod G if G is nonzero (from para.Gk).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zou-Bo/MomentumED.jl/blob/e69db134d5297dd85a3020ba2ceb80e32c146fc5/MomentumED/src/preparation/momentum_decomposition.jl#L43-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MomentumED.Preparation.group_momentum_pairs-Tuple{EDPara}" href="#MomentumED.Preparation.group_momentum_pairs-Tuple{EDPara}"><code>MomentumED.Preparation.group_momentum_pairs</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">group_momentum_pairs(para::EDPara) -&gt; Dict{Tuple{Int64,Int64}, Vector{Tuple{Int64,Int64}}}</code></pre><p>Generate grouped momentum pairs by their total momentum.</p><p>Creates a dictionary mapping total momentum quantum numbers to lists of  momentum index pairs that conserve that total momentum.</p><p><strong>Arguments</strong></p><ul><li><code>para::EDPara</code>: Parameter structure containing system configuration</li></ul><p><strong>Returns</strong></p><ul><li><code>Dict{Tuple{Int64,Int64}, Vector{Tuple{Int64,Int64}}}</code>: Dictionary where:<ul><li>Keys are total momentum tuples <code>(K1, K2)</code></li><li>Values are vectors of momentum index pairs <code>[(i,j), ...]</code> with that total momentum</li></ul></li></ul><p><strong>Details</strong></p><ul><li>Generates all possible pairs <code>(i,j)</code> with <code>i &gt;= j</code> to avoid duplicates</li><li>Uses <code>MBS_totalmomentum(para, i, j)</code> to compute total momentum for each pair</li><li>Essential for efficient two-body Scatter term generation</li><li>Enables momentum conservation enforcement in Hamiltonian construction</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">para = EDPara(k_list=k_list, Gk=(3, 5), V_int=V_int)
groups = group_momentum_pairs(para)
# Access all pairs with total momentum (0, 0)
pairs_with_zero_momentum = groups[(0, 0)]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zou-Bo/MomentumED.jl/blob/e69db134d5297dd85a3020ba2ceb80e32c146fc5/MomentumED/src/preparation/scat_list.jl#L51-L80">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MomentumED.Preparation.mbslist_onecomponent-Tuple{EDPara, Int64}" href="#MomentumED.Preparation.mbslist_onecomponent-Tuple{EDPara, Int64}"><code>MomentumED.Preparation.mbslist_onecomponent</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mbslist_onecomponent(para::EDPara, N_in_one::Int64[, mask])</code></pre><p>Construct the MBS list(iterator) of N electrons in one conserved component.</p><p>Generates all possible MBS64 states with exactly N<em>in</em>one particles in the specified component, using combinations of orbital indices.</p><p><strong>Arguments</strong></p><ul><li><code>para::EDPara</code>: Parameter structure containing momentum and component information</li><li><code>N_in_one::Int64</code>: Number of particles in the conserved component</li></ul><p><strong>Returns</strong></p><ul><li><code>Iterator{MBS64}</code>: Sorted list of MBS64 states with specified particle number</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">para = EDPara(k_list=[0 1; 0 0], Nc_hopping=1, Nc_conserve=1)
states = ED_mbslist_onecomponent(para, 2)  # 2 particles in 2 orbitals</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zou-Bo/MomentumED.jl/blob/e69db134d5297dd85a3020ba2ceb80e32c146fc5/MomentumED/src/preparation/momentum_decomposition.jl#L9-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MomentumED.Preparation.mbslist_recursive_iteration!-Union{Tuple{bits}, Tuple{Array{HilbertSubspace{bits}, 1}, Vector{Int64}, Vector{Int64}, EDPara, Vector{Int64}}, Tuple{Array{HilbertSubspace{bits}, 1}, Vector{Int64}, Vector{Int64}, EDPara, Vector{Int64}, MBS64}, Tuple{Array{HilbertSubspace{bits}, 1}, Vector{Int64}, Vector{Int64}, EDPara, Vector{Int64}, MBS64, Tuple{Int64, Int64}}} where bits" href="#MomentumED.Preparation.mbslist_recursive_iteration!-Union{Tuple{bits}, Tuple{Array{HilbertSubspace{bits}, 1}, Vector{Int64}, Vector{Int64}, EDPara, Vector{Int64}}, Tuple{Array{HilbertSubspace{bits}, 1}, Vector{Int64}, Vector{Int64}, EDPara, Vector{Int64}, MBS64}, Tuple{Array{HilbertSubspace{bits}, 1}, Vector{Int64}, Vector{Int64}, EDPara, Vector{Int64}, MBS64, Tuple{Int64, Int64}}} where bits"><code>MomentumED.Preparation.mbslist_recursive_iteration!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mbslist_recursive_iteration!(subspaces, subspace_k1, subspace_k2, para, N_each_component, accumulated_mbs, accumulated_momentum; mask=nothing)</code></pre><p>An internal recursive function that constructs many-body states and sorts them into momentum subspaces.</p><p>The function works by processing one conserved component at a time. It iterates through all valid states for the current component and then calls itself recursively for the next component, accumulating the state (<code>MBS64</code>) and total momentum.</p><p><strong>Recursion Logic</strong></p><p>The recursion proceeds from the last element of <code>N_each_component</code> to the first. In each step, it generates all possible states for the current component based on the particle number <code>abs(N_each_component[end])</code> and combines them (via <code>*</code>) with the <code>accumulated_mbs</code> from the previous steps. The momentum is also updated.</p><p>When the recursion is complete (<code>N_each_component</code> is empty), the final state and its total momentum are known, and the state is pushed into the correct momentum subspace in <code>subspaces</code>.</p><p><strong>Particle vs. Hole Creation</strong></p><p>The sign of the number in <code>N_each_component</code> determines whether particles or holes are created:</p><ul><li><strong>Positive <code>N</code></strong>: Creates <code>N</code> particles in an empty sea of orbitals for the current component.</li><li><strong>Negative <code>N</code></strong>: Creates <code>abs(N)</code> holes in a filled sea of orbitals. This is used for calculations like the particle reduced density matrix where one considers states in the complementary space.</li></ul><p><strong>Keywords</strong></p><p>The <code>mask</code> argument, if provided, restricts the set of orbitals that can be occupied (for positive <code>N</code>) or made into holes (for negative <code>N</code>) for the single-component states. <code>mask</code> is a Vector{Int64} and must be sorted.</p><p><code>check_mask_sorted::Bool=false</code> will assert <code>mask</code> is sorted if it&#39;s provided.  It will only check once at the begining of outermost iteration.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zou-Bo/MomentumED.jl/blob/e69db134d5297dd85a3020ba2ceb80e32c146fc5/MomentumED/src/preparation/momentum_decomposition.jl#L82-L105">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MomentumED.Preparation.scat_pair_group_coordinate-Union{Tuple{T}, Tuple{Vector{Tuple{Int64, Int64}}, EDPara}} where T&lt;:Real" href="#MomentumED.Preparation.scat_pair_group_coordinate-Union{Tuple{T}, Tuple{Vector{Tuple{Int64, Int64}}, EDPara}} where T&lt;:Real"><code>MomentumED.Preparation.scat_pair_group_coordinate</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">scat_pair_group_coordinate(pair_group, para, shifts) -&gt; Vector{Scatter{2}}</code></pre><p>Generate all Scatter terms between momentum pairs with the same total momentum. This internal function uses an interaction function <code>V_int</code> that accepts momentum coordinates.</p><p><strong>Arguments</strong></p><ul><li><code>pair_group::Vector{Tuple{Int64,Int64}}</code>: List of momentum index pairs with the same total momentum.</li><li><code>para::EDPara</code>: Parameter structure containing system configuration.</li><li><code>shifts::Matrix{&lt;:Real}</code>: A matrix of size <code>(2, Nc_conserve)</code> specifying the momentum shifts (twisted boundary conditions) for each conserved component.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Scatter{2}}</code>: A list of two-body <code>Scatter</code> terms for this momentum group.</li></ul><p><strong>Details</strong></p><ul><li>Iterates over all input/output momentum pair combinations within the group.</li><li>Generates all component index combinations for each momentum pair.</li><li>Maps momentum and component indices to global orbital indices.</li><li>Applies normal ordering: <code>minmax(i1, i2) &gt;= minmax(f1, f2)</code>.</li><li>Calculates Scatter amplitudes using <code>para.V_int</code> with momentum shifts.</li><li>Includes both direct (<code>V(f1,f2,i2,i1)</code>) and exchange (<code>V(f1,f2,i1,i2)</code>) contributions.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zou-Bo/MomentumED.jl/blob/e69db134d5297dd85a3020ba2ceb80e32c146fc5/MomentumED/src/preparation/scat_list.jl#L103-L124">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MomentumED.Preparation.scat_pair_group_index-Tuple{Vector{Tuple{Int64, Int64}}, EDPara}" href="#MomentumED.Preparation.scat_pair_group_index-Tuple{Vector{Tuple{Int64, Int64}}, EDPara}"><code>MomentumED.Preparation.scat_pair_group_index</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">scat_pair_group_index(pair_group, para) -&gt; Vector{Scatter{2}}</code></pre><p>Generate all Scatter terms between momentum pairs with the same total momentum. This internal function uses an interaction function <code>V_int</code> that accepts momentum indices.</p><p><strong>Arguments</strong></p><ul><li><code>pair_group::Vector{Tuple{Int64,Int64}}</code>: List of momentum index pairs with the same total momentum.</li><li><code>para::EDPara</code>: Parameter structure containing system configuration.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Scatter{2}}</code>: A list of two-body <code>Scatter</code> terms for this momentum group.</li></ul><p><strong>Details</strong></p><ul><li>This function is used when <code>para.V_int</code> expects integer indices instead of coordinates.</li><li>It does not handle momentum shifts (twisted boundary conditions); the <code>para</code> object itself should be updated if necessary.</li><li>Iterates over all input/output momentum pair combinations within the group.</li><li>Applies normal ordering and calculates direct and exchange amplitudes.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zou-Bo/MomentumED.jl/blob/e69db134d5297dd85a3020ba2ceb80e32c146fc5/MomentumED/src/preparation/scat_list.jl#L230-L248">source</a></section></article><h2 id="Methods"><a class="docs-heading-anchor" href="#Methods">Methods</a><a id="Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Methods" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MomentumED.Methods" href="#MomentumED.Methods"><code>MomentumED.Methods</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>This module provides methods of generating Hamiltonian sparse matrix or Hamiltonian linear map, and use KrylovKit to solve them.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zou-Bo/MomentumED.jl/blob/e69db134d5297dd85a3020ba2ceb80e32c146fc5/MomentumED/src/MomentumED.jl#L107-L110">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MomentumED.Methods.ED_HamiltonianMatrix_threaded-Tuple{HilbertSubspace, Vararg{Vector{&lt;:Scatter}}}" href="#MomentumED.Methods.ED_HamiltonianMatrix_threaded-Tuple{HilbertSubspace, Vararg{Vector{&lt;:Scatter}}}"><code>MomentumED.Methods.ED_HamiltonianMatrix_threaded</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ED_HamiltonianMatrix_threaded(sorted_mbs_block_list, sorted_scat_lists...)</code></pre><p>Threaded version of generating Hamiltonian Matrix with pre-computed state mapping and COO format construction.</p><p><strong>Arguments</strong></p><ul><li><code>sorted_mbs_block_list::Vector{&lt;: MBS64}</code>: Sorted basis states for momentum block</li><li><code>sorted_scat_lists::Vector{&lt;: Scatter}</code>: lists of Scatter terms (one-body, two-body, etc.)</li></ul><p><strong>Keywords</strong></p><ul><li><code>element_type::Type=Float64</code>: Element type of the sparse matrix (Float64, Float32, Float16)</li><li><code>index_type::Type=Int64</code>: Index type of the sparse matrix (Int64, Int32, Int16, Int8)</li></ul><p><strong>Returns</strong></p><ul><li><code>SparseMatrixCSC</code>: Sparse Hamiltonian matrix</li></ul><p><strong>Notes</strong></p><p>Uses COO format construction with thread-local storage for better parallel performance. Provides 4-8x speedup for medium to large systems compared to the one-thread version.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zou-Bo/MomentumED.jl/blob/e69db134d5297dd85a3020ba2ceb80e32c146fc5/MomentumED/src/method/sparse_matrix.jl#L13-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MomentumED.Methods.krylov_map_solve-Union{Tuple{eltype}, Tuple{bits}, Tuple{MomentumED.Methods.LinearMap{bits, eltype}, Int64}} where {bits, eltype&lt;:AbstractFloat}" href="#MomentumED.Methods.krylov_map_solve-Union{Tuple{eltype}, Tuple{bits}, Tuple{MomentumED.Methods.LinearMap{bits, eltype}, Int64}} where {bits, eltype&lt;:AbstractFloat}"><code>MomentumED.Methods.krylov_map_solve</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">krylov_map_solve(H::SparseMatrixCSC{ComplexF64, Int64}, N_eigen::Int64=6; 
    converge_warning::Bool=false, krylovkit_kwargs...) -&gt; (vals, vecs)</code></pre><p>Solve the sparse Hamiltonian matrix using KrylovKit&#39;s eigsolve function for the lowest <code>N_eigen</code> eigenvalues and eigenvectors.</p><p><strong>Arguments</strong></p><ul><li><code>H::SparseMatrixCSC{Complex{eltype}, idtype}</code>: Sparse Hamiltonian matrix to diagonalize</li><li><code>N_eigen::Int64=6</code>: Number of eigenvalues/eigenvectors to compute (default: 6)</li></ul><p><strong>Keywords</strong></p><ul><li><code>vec0::Vector{Complex{eltype}}=rand(Complex{eltype}, H.m)</code>: Initial guess vector for Krylov iteration</li><li><code>ishermitian::Bool=true</code>: Whether the matrix is Hermitian (default: true)</li><li><code>krylovkit_kwargs...</code>: Additional keyword arguments to pass to KrylovKit.eigsolve</li></ul><p><strong>Returns</strong></p><ul><li><code>vals::Vector{eltype}</code>: Eigenvalues (energies) in ascending order</li><li><code>vecs::Vector{Vector{Complex{eltype}}}</code>: Corresponding eigenvectors</li><li><code>info</code>: Convergence information from KrylovKit</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Solve for 3 lowest eigenstates
vals, vecs, info = krylov_map_solve(H_map, 3)
println(&quot;Ground state energy: &quot;, vals[1])</code></pre><p><strong>Notes</strong></p><ul><li>Uses KrylovKit&#39;s eigsolve with :SR (smallest real) eigenvalue selection</li><li>Assumes Hermitian matrix (standard for quantum Hamiltonians)</li><li>Random initial vector ensures good convergence properties</li><li>Automatically handles convergence warnings from KrylovKit</li><li>For better control over convergence, consider using KrylovKit directly</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zou-Bo/MomentumED.jl/blob/e69db134d5297dd85a3020ba2ceb80e32c146fc5/MomentumED/src/method/linear_map.jl#L132-L165">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MomentumED.Methods.krylov_matrix_solve-Union{Tuple{eltype}, Tuple{SparseArrays.SparseMatrixCSC{Complex{eltype}}, Int64}} where eltype&lt;:AbstractFloat" href="#MomentumED.Methods.krylov_matrix_solve-Union{Tuple{eltype}, Tuple{SparseArrays.SparseMatrixCSC{Complex{eltype}}, Int64}} where eltype&lt;:AbstractFloat"><code>MomentumED.Methods.krylov_matrix_solve</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">krylov_matrix_solve(H::SparseMatrixCSC{ComplexF64, Int64}, N_eigen::Int64=6; 
    converge_warning::Bool=false, krylovkit_kwargs...) -&gt; (vals, vecs)</code></pre><p>Solve the sparse Hamiltonian matrix using KrylovKit&#39;s eigsolve function for the lowest <code>N_eigen</code> eigenvalues and eigenvectors.</p><p><strong>Arguments</strong></p><ul><li><code>H::SparseMatrixCSC{Complex{eltype}, idtype}</code>: Sparse Hamiltonian matrix to diagonalize</li><li><code>N_eigen::Int64=6</code>: Number of eigenvalues/eigenvectors to compute (default: 6)</li></ul><p><strong>Keywords</strong></p><ul><li><code>vec0::Vector{Complex{eltype}}=rand(Complex{eltype}, H.m)</code>: Initial guess vector for Krylov iteration</li><li><code>ishermitian::Bool=true</code>: Whether the matrix is Hermitian (default: true)</li><li><code>krylovkit_kwargs...</code>: Additional keyword arguments to pass to KrylovKit.eigsolve</li></ul><p><strong>Returns</strong></p><ul><li><code>vals::Vector{eltype}</code>: Eigenvalues (energies) in ascending order</li><li><code>vecs::Vector{Vector{Complex{eltype}}}</code>: Corresponding eigenvectors</li><li><code>info</code>: Convergence information from KrylovKit</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Solve for 3 lowest eigenstates
vals, vecs, info = krylov_matrix_solve(H_matrix, 3)
println(&quot;Ground state energy: &quot;, vals[1])</code></pre><p><strong>Notes</strong></p><ul><li>Uses KrylovKit&#39;s eigsolve with :SR (smallest real) eigenvalue selection</li><li>Assumes Hermitian matrix (standard for quantum Hamiltonians)</li><li>Random initial vector ensures good convergence properties</li><li>Automatically handles convergence warnings from KrylovKit</li><li>For better control over convergence, consider using KrylovKit directly</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zou-Bo/MomentumED.jl/blob/e69db134d5297dd85a3020ba2ceb80e32c146fc5/MomentumED/src/method/sparse_matrix.jl#L88-L121">source</a></section></article><h2 id="Analysis"><a class="docs-heading-anchor" href="#Analysis">Analysis</a><a id="Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Analysis" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MomentumED.Analysis" href="#MomentumED.Analysis"><code>MomentumED.Analysis</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>This module provides methods to analysis the ED eigenwavefunctions, including generating particle(hole)/orbital reduced density matrix for entanglement spectrum analysis,  and many-body connection analysis with momentum shifts</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zou-Bo/MomentumED.jl/blob/e69db134d5297dd85a3020ba2ceb80e32c146fc5/MomentumED/src/MomentumED.jl#L300-L304">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MomentumED.Analysis.ED_connection_gaugefixing!" href="#MomentumED.Analysis.ED_connection_gaugefixing!"><code>MomentumED.Analysis.ED_connection_gaugefixing!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Modify the overall phase of eigenvectors. This is a preparation for many-body connection Wilson loop integral.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zou-Bo/MomentumED.jl/blob/e69db134d5297dd85a3020ba2ceb80e32c146fc5/MomentumED/src/analysis/manybody_connection.jl#L11-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MomentumED.Analysis.ED_connection_step-Union{Tuple{MbsVec}, Tuple{MbsVec, MbsVec, Tuple{Float64, Float64}, Tuple{Float64, Float64}, EDPara}} where MbsVec&lt;:MBS64Vector" href="#MomentumED.Analysis.ED_connection_step-Union{Tuple{MbsVec}, Tuple{MbsVec, MbsVec, Tuple{Float64, Float64}, Tuple{Float64, Float64}, EDPara}} where MbsVec&lt;:MBS64Vector"><code>MomentumED.Analysis.ED_connection_step</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ED_connection_step(mbs_list::Vector{MBS64}, ψ_f::Vector{ComplexF64}, ψ_i::Vector{ComplexF64},
                   shift_f::Tuple{Float64, Float64}, shift_i::Tuple{Float64, Float64},
                   para::EDPara; wavefunction_tol::Float64=1e-8, amp_warn_tol::Float64=0.6,
                   amp_warn::Bool=true)</code></pre><p>Compute the many-body Berry connection integral between two kshift points in momentum space.</p><p><strong>Arguments</strong></p><ul><li><code>mbs_list::Vector{MBS64}</code>: List of many-body states in this momentum block</li><li><code>ψ_f::Vector{ComplexF64}</code>: Eigenvector at shift_f</li><li><code>ψ_i::Vector{ComplexF64}</code>: Eigenvector at shift_i</li><li><code>shift_f::Tuple{Float64, Float64}</code>: Final momentum shift</li><li><code>shift_i::Tuple{Float64, Float64}</code>: Initial momentum shift</li><li><code>para::EDPara</code>: ED parameters containing momentum states and system details</li></ul><p><strong>Keywords</strong></p><ul><li><code>wavefunction_tol::Float64=1e-8</code>: Minimum amplitude in eigenvectors to consider</li><li><code>amp_warn_tol::Float64=0.6</code>: Minimum inner product amplitude to avoid numerical instability warning</li><li><code>amp_warn::Bool=true</code>: Whether to issue a warning for small inner product amplitude</li></ul><p><strong>Returns</strong></p><ul><li><code>Float64</code>: Step integral of many-body connection = arg( ⟨ψ2|ψ1⟩ )</li></ul><p><strong>Description</strong></p><p>The many-body Berry connection step integral is computed as the phase of the inner product For small twist difference δshift = shift<em>f - shift</em>i, inner product ⟨ψ2|ψ1⟩ ≈ exp(i * ∫ A ⋅ δshift) Step integral = arg(⟨ψ2|ψ1⟩)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zou-Bo/MomentumED.jl/blob/e69db134d5297dd85a3020ba2ceb80e32c146fc5/MomentumED/src/analysis/manybody_connection.jl#L42-L70">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MomentumED.Analysis.OES_NumMomtBlock_coef-Union{Tuple{F}, Tuple{bits}, Tuple{EDPara, MBS64Vector{bits, F}, Tuple{Real, Real}, Array{HilbertSubspace{bits}, 1}, Array{HilbertSubspace{bits}, 1}, Vector{Tuple{Int64, Int64}}, Vector{Tuple{Int64, Int64}}}} where {bits, F&lt;:AbstractFloat}" href="#MomentumED.Analysis.OES_NumMomtBlock_coef-Union{Tuple{F}, Tuple{bits}, Tuple{EDPara, MBS64Vector{bits, F}, Tuple{Real, Real}, Array{HilbertSubspace{bits}, 1}, Array{HilbertSubspace{bits}, 1}, Vector{Tuple{Int64, Int64}}, Vector{Tuple{Int64, Int64}}}} where {bits, F&lt;:AbstractFloat}"><code>MomentumED.Analysis.OES_NumMomtBlock_coef</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">docstring needed.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zou-Bo/MomentumED.jl/blob/e69db134d5297dd85a3020ba2ceb80e32c146fc5/MomentumED/src/analysis/orbital_reduced_density_matrix.jl#L45-L47">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MomentumED.Analysis.OES_NumMomtBlocks-Tuple{EDPara, Any, Union{Tuple{Vararg{Int64}}, Vector{Int64}}}" href="#MomentumED.Analysis.OES_NumMomtBlocks-Tuple{EDPara, Any, Union{Tuple{Vararg{Int64}}, Vector{Int64}}}"><code>MomentumED.Analysis.OES_NumMomtBlocks</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">docstring needed</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zou-Bo/MomentumED.jl/blob/e69db134d5297dd85a3020ba2ceb80e32c146fc5/MomentumED/src/analysis/orbital_reduced_density_matrix.jl#L1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MomentumED.Analysis.PES_1rdm-Union{Tuple{MBS64Vector{bits, F}}, Tuple{F}, Tuple{bits}} where {bits, F&lt;:AbstractFloat}" href="#MomentumED.Analysis.PES_1rdm-Union{Tuple{MBS64Vector{bits, F}}, Tuple{F}, Tuple{bits}} where {bits, F&lt;:AbstractFloat}"><code>MomentumED.Analysis.PES_1rdm</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Simple way of generating one-body reduced density.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zou-Bo/MomentumED.jl/blob/e69db134d5297dd85a3020ba2ceb80e32c146fc5/MomentumED/src/analysis/particle_reduced_density_matrix.jl#L1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MomentumED.Analysis.PES_MomtBlock_rdm-Union{Tuple{F}, Tuple{bits}, Tuple{EDPara, MBS64Vector{bits, F}, HilbertSubspace{bits}}, Tuple{EDPara, MBS64Vector{bits, F}, HilbertSubspace{bits}, BitVector}} where {bits, F&lt;:AbstractFloat}" href="#MomentumED.Analysis.PES_MomtBlock_rdm-Union{Tuple{F}, Tuple{bits}, Tuple{EDPara, MBS64Vector{bits, F}, HilbertSubspace{bits}}, Tuple{EDPara, MBS64Vector{bits, F}, HilbertSubspace{bits}, BitVector}} where {bits, F&lt;:AbstractFloat}"><code>MomentumED.Analysis.PES_MomtBlock_rdm</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zou-Bo/MomentumED.jl/blob/e69db134d5297dd85a3020ba2ceb80e32c146fc5/MomentumED/src/analysis/particle_reduced_density_matrix.jl#L35">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../EDCore/api/">« API Reference</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.15.0 on <span class="colophon-date" title="Saturday 1 November 2025 01:09">Saturday 1 November 2025</span>. Using Julia version 1.12.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
