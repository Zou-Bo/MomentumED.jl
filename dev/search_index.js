var documenterSearchIndex = {"docs":
[{"location":"EDCore/api/#EDCore-API-Reference","page":"API Reference","title":"EDCore API Reference","text":"","category":"section"},{"location":"EDCore/api/#Many-Body-Basis","page":"API Reference","title":"Many-Body Basis","text":"","category":"section"},{"location":"EDCore/api/#Types","page":"API Reference","title":"Types","text":"","category":"section"},{"location":"EDCore/api/#EDCore.MBS64","page":"API Reference","title":"EDCore.MBS64","text":"MBS64{bits}\n\nMany-body state representation using 64-bit unsigned integers.\n\nEach bit represents the occupation of an orbital (1 = occupied, 0 = empty). The bits parameter specifies how many orbitals are physically meaningful.\n\nFields\n\nn::UInt64: The bit representation of occupied orbitals\n\nConstructor\n\nMBS64{bits}(state::UInt64)\n\nCreates a new MBS64 with the given bit state, validating that the state fits within the specified number of bits.\n\nReinterpret Construction Example\n\nreinterpret(MBS64{20}, UInt(250))\n\nThis may generate an unphysical state because reinterpret bypasses the constructor's validation, potentially setting bits beyond the bits parameter.\n\n\n\n\n\n","category":"type"},{"location":"EDCore/api/#Base.show-Tuple{IO, MBS64}","page":"API Reference","title":"Base.show","text":"Base.show(io::IO, mbs::MBS64{bits}) where bits\n\nDisplay the MBS64 state in a human-readable format showing the bit pattern.\n\n\n\n\n\n","category":"method"},{"location":"EDCore/api/#Functions","page":"API Reference","title":"Functions","text":"","category":"section"},{"location":"EDCore/api/#EDCore.get_bits-Union{Tuple{MBS64{bits}}, Tuple{bits}} where bits","page":"API Reference","title":"EDCore.get_bits","text":"get_bits(mbs::MBS64{bits}) = bits\n\nReturn the number of physical bits of the type of input mbs state.\n\n\n\n\n\nget_bits(space::HilbertSubspace{bits})::Integer\n\nReturns the number of bits used to represent the MBS64 states in the Hilbert subspace.\n\n\n\n\n\n","category":"method"},{"location":"EDCore/api/#EDCore.isphysical","page":"API Reference","title":"EDCore.isphysical","text":"isphysical(mbs::MBS64{bits})::Bool\n\nCheck if all indices of occupied orbitals are smaller than or equal to bits.\n\n\n\n\n\n","category":"function"},{"location":"EDCore/api/#EDCore.occ_list","page":"API Reference","title":"EDCore.occ_list","text":"occ_list(mbs::MBS64{bits}) where {bits}\n\nReturn the list of occupied orbital indices (1-based) in the many-body state.\n\n\n\n\n\n","category":"function"},{"location":"EDCore/api/#EDCore.make_mask64","page":"API Reference","title":"EDCore.make_mask64","text":"make_mask64(occ_list::Vector{Int64})::UInt64\nmake_mask64(occ_list)::UInt64 = make_mask64(collect(occ_list))\nmake_mask64(occ_list::Tuple{Int64})::UInt64\nmake_mask64(occ_list::Tuple{Int64, Int64})::UInt64\n\nCreate mask with ones on the assigned bit positions. Bit positions should be >= 1 and <= 64. Repeating positions only take effect once.\n\nOptimized for one and two occupations.\n\n\n\n\n\n","category":"function"},{"location":"EDCore/api/#EDCore.MBS64-Tuple{Any, Any}","page":"API Reference","title":"EDCore.MBS64","text":"MBS64(bits, occ_list[, mask])\n\nConstruct an MBS64 from an iterable list of occupied orbitals.  No repetition allowed.\n\nIf a mask is specified, occ_list refers to the indices within that mask that should be set to occupied. For example, if mask represents orbitals [1, 3, 5] and occ_list is [1, 2], then orbitals 1 and 3 (from the mask) will be occupied.\n\n\n\n\n\n","category":"method"},{"location":"EDCore/api/#EDCore.MBS64_complete","page":"API Reference","title":"EDCore.MBS64_complete","text":"MBS64_complete(mbs::MBS64{bits})::MBS64{bits}\n\nReturn the complete occupation of a MBS64{bits}.\n\n\n\n\n\n","category":"function"},{"location":"EDCore/api/#Base.:*-Union{Tuple{b}, Tuple{MBS64{b}, MBS64{b}}} where b","page":"API Reference","title":"Base.:*","text":"*(mbs1::MBS64{b1}, mbs2::MBS64{b2}) where {b1, b2}\n\nCombine(concatenate) two MBS64 states from two orthogonal Hilbert spaces. The first state accounts greater bit positions and the second smaller positions. Used for combining states from different components.\n\n\n\n\n\n","category":"method"},{"location":"EDCore/api/#Base.:+-Union{Tuple{b}, Tuple{MBS64{b}, MBS64{b}}} where b","page":"API Reference","title":"Base.:+","text":"+(mbs1::MBS64{b}, mbs2::MBS64{b})::MBS64{b} where {b}\n\nCombine(plus) two MBS64 states in the same(combined) Hilbert space with mbs1.n | mbs2.n. Used for combining states generated with complete masks. Repeated occupations on the same bit, if exist, count once.\n\n\n\n\n\n","category":"method"},{"location":"EDCore/api/#Base.isless-Union{Tuple{b}, Tuple{MBS64{b}, MBS64{b}}} where b","page":"API Reference","title":"Base.isless","text":"isless(mbs1::MBS64{b}, mbs2::MBS64{b}) where {b}\n\nComparison operators for sorting MBS64 states.\n\n\n\n\n\n","category":"method"},{"location":"EDCore/api/#Base.:==-Union{Tuple{b2}, Tuple{b1}, Tuple{MBS64{b1}, MBS64{b2}}} where {b1, b2}","page":"API Reference","title":"Base.:==","text":"==(mbs1::MBS64{b1}, mbs2::MBS64{b2}) where {b1, b2}\n==(int::Integer, mbs2::MBS64{b}) where {b}\n==(mbs1::MBS64{b}, int::Integer) where {b}\n\nCheck equality of two MBS64 states. Different bit sizes are never equal.\n\n\n\n\n\n","category":"method"},{"location":"EDCore/api/#Base.hash-Tuple{MBS64}","page":"API Reference","title":"Base.hash","text":"hash(mbs::MBS64) = hash(mbs.n)\n\nComputes the hash of a many-body state, which is equivalent to the hash of its underlying integer representation mbs.n.\n\n\n\n\n\n","category":"method"},{"location":"EDCore/api/#EDCore.isoccupied","page":"API Reference","title":"EDCore.isoccupied","text":"isoccupied(mbs::MBS64{bits}, i_list::UInt64) where {bits}\nisoccupied(mbs::MBS64{bits}, i_list::Vector{Int64}) where {bits}\nisoccupied(mbs::MBS64{bits}, i_list::Tuple{Vararg{Int64}}) where {bits}\n\nCheck if the specified orbital(s) are all occupied in the many-body state. Returns true if all specified orbitals are occupied.\n\n\n\n\n\n","category":"function"},{"location":"EDCore/api/#Base.isempty-Union{Tuple{bits}, Tuple{MBS64{bits}, UInt64}} where bits","page":"API Reference","title":"Base.isempty","text":"isempty(mbs::MBS64{bits}, i_list::UInt64) where {bits}\nisempty(mbs::MBS64{bits}, i_list::Vector{Int64}) where {bits}\nisempty(mbs::MBS64{bits}, i_list::Tuple{Vararg{Int64}}) where {bits}\n\nCheck if the specified orbital(s) are all empty in the many-body state. Returns true if all specified orbitals are empty.\n\n\n\n\n\n","category":"method"},{"location":"EDCore/api/#EDCore.occupy!","page":"API Reference","title":"EDCore.occupy!","text":"occupy!(mbs::MBS64{bits}, i_list::UInt64; check::Bool=true) where {bits}\noccupy!(mbs::MBS64{bits}, i_list::Vector{Int64}; check::Bool=true) where {bits}\noccupy!(mbs::MBS64{bits}, i_list::Tuple{Vararg{Int64}}; check::Bool=true) where {bits}\n\nCreate a new MBS64 with the specified orbital(s) occupied. If check=true, verifies that the orbitals were originally empty.\n\n\n\n\n\n","category":"function"},{"location":"EDCore/api/#Base.empty!-Union{Tuple{bits}, Tuple{MBS64{bits}, UInt64}} where bits","page":"API Reference","title":"Base.empty!","text":"empty!(mbs::MBS64{bits}, i_list::UInt64; check::Bool=true) where {bits}\nempty!(mbs::MBS64{bits}, i_list::Vector{Int64}; check::Bool=true) where {bits}\nempty!(mbs::MBS64{bits}, i_list::Tuple{Vararg{Int64}}; check::Bool=true) where {bits}\n\nCreate a new MBS64 with the specified orbital(s) emptied. If check=true, verifies that the orbitals were originally occupied.\n\n\n\n\n\n","category":"method"},{"location":"EDCore/api/#EDCore.flip!","page":"API Reference","title":"EDCore.flip!","text":"flip!(mbs::MBS64{bits}, i_list::UInt64) where {bits}\nflip!(mbs::MBS64{bits}, i_list::Vector{Int64}) where {bits}\nflip!(mbs::MBS64{bits}, i_list::Tuple{Vararg{Int64}}) where {bits}\n\nCreate a new MBS64 with flipped occupations in the specified orbital(s).\n\n\n\n\n\n","category":"function"},{"location":"EDCore/api/#EDCore.scat_occ_number","page":"API Reference","title":"EDCore.scat_occ_number","text":"scat_occ_number(mbs::MBS64{bits}, i_list::Vector{Int64})::Int64 where {bits}\nscat_occ_number(mbs::MBS64{bits}, i_list::Tuple{Vararg{Int64}})::Int64 where {bits}\nscat_occ_number(mbs::MBS64{bits}, i_list::Tuple{Int64})::Int64 where {bits}\nscat_occ_number(mbs::MBS64{bits}, i_list::Tuple{Int64, Int64})::Int64 where {bits}\n\nCount the total number of occupied orbitals that contribute to the sign flip when applying a series of creation/annihilation operators. When a Scatter{N} object is applied, the number of sign flips should be the sum of  applying the creation ilist and annihilation ilist on the middle state.\n\nOptimized for one-body and two-body Scatter with Tuple input.\n\n\n\n\n\n","category":"function"},{"location":"EDCore/api/#Generating-Sorted-List","page":"API Reference","title":"Generating Sorted List","text":"","category":"section"},{"location":"EDCore/api/#EDCore.ColexMBS64","page":"API Reference","title":"EDCore.ColexMBS64","text":"The Combinations iterator in colex order (meaning sorted MBS64 list)\n\nfor mbs in ColexMBS64(7, 3)\n    println(mbs)\nend\n\n\n\n\n\n","category":"type"},{"location":"EDCore/api/#EDCore.ColexMBS64Mask","page":"API Reference","title":"EDCore.ColexMBS64Mask","text":"The Combinations iterator in colex order where occupied orbitals are in the mask. Returning list is sorted when the mask is sorted.\n\nfor mbs in ColexMBS64Mask(7, 3, [1; 2; 5; 6; 7])\n    println(mbs)\nend\n\n\n\n\n\n","category":"type"},{"location":"EDCore/api/#Hilbert-Subspace","page":"API Reference","title":"Hilbert Subspace","text":"","category":"section"},{"location":"EDCore/api/#Types-2","page":"API Reference","title":"Types","text":"","category":"section"},{"location":"EDCore/api/#EDCore.HilbertSubspace","page":"API Reference","title":"EDCore.HilbertSubspace","text":"HilbertSubspace{bits}\n\nRepresents a Hilbert subspace defined by a list of many-body states (MBS64). Optionally includes a dictionary for efficient state-to-index lookup.\n\nFields\n\nlist::Vector{MBS64{bits}}: A sorted list of MBS64 states forming the basis of the subspace.\ndict::Dict{MBS64{bits}, <: Integer}: An optional dictionary mapping MBS64 states to their 1-based indices in list.\n\nNotice that dict takes lots of memory and can only accelerate searching in very very large subspace.\n\nConstructors\n\nHilbertSubspace(sorted_list::Vector{MBS64{bits}}; dict::Bool = false, index_type::Type = Int64) where {bits}\n\nConstructs a HilbertSubspace from a sorted list of MBS64 states. If dict is true, a state-to-index dictionary is pre-built.\n\n\n\n\n\n","category":"type"},{"location":"EDCore/api/#Base.show-Tuple{IO, MIME{Symbol(\"text/plain\")}, HilbertSubspace}","page":"API Reference","title":"Base.show","text":"Base.show(io::IO, mime::MIME\"text/plain\", space::HilbertSubspace{bits}) where {bits}\n\nDisplays a human-readable representation of the HilbertSubspace, including its bit size, dimension, and whether a dictionary is present.\n\n\n\n\n\n","category":"method"},{"location":"EDCore/api/#Functions-2","page":"API Reference","title":"Functions","text":"","category":"section"},{"location":"EDCore/api/#EDCore.idtype","page":"API Reference","title":"EDCore.idtype","text":"idtype(space::HilbertSubspace)::Type\n\nReturns the type of the index used in the HilbertSubspace's dictionary.\n\n\n\n\n\n","category":"function"},{"location":"EDCore/api/#EDCore.get_bits-Tuple{HilbertSubspace}","page":"API Reference","title":"EDCore.get_bits","text":"get_bits(mbs::MBS64{bits}) = bits\n\nReturn the number of physical bits of the type of input mbs state.\n\n\n\n\n\nget_bits(space::HilbertSubspace{bits})::Integer\n\nReturns the number of bits used to represent the MBS64 states in the Hilbert subspace.\n\n\n\n\n\n","category":"method"},{"location":"EDCore/api/#Base.length-Tuple{HilbertSubspace}","page":"API Reference","title":"Base.length","text":"length(space::HilbertSubspace)\n\nReturns the number of states in the Hilbert subspace (space dimension).\n\n\n\n\n\n","category":"method"},{"location":"EDCore/api/#EDCore.make_dict!","page":"API Reference","title":"EDCore.make_dict!","text":"make_dict!(space::HilbertSubspace; index_type::Type = idtype(space))\n\nCreates or recreates the state-to-index dictionary for the given HilbertSubspace. This can be useful if the dict field was not initialized or was emptied.\n\n\n\n\n\n","category":"function"},{"location":"EDCore/api/#EDCore.delete_dict!","page":"API Reference","title":"EDCore.delete_dict!","text":"delete_dict!(space::HilbertSubspace)\n\nDeletes (empties) the state-to-index dictionary from the HilbertSubspace to free up memory.\n\n\n\n\n\n","category":"function"},{"location":"EDCore/api/#Base.get-Union{Tuple{bits}, Tuple{HilbertSubspace{bits}, MBS64{bits}}} where bits","page":"API Reference","title":"Base.get","text":"Base.get(space::HilbertSubspace{bits}, mbs::MBS64{bits})::Int64\n\nRetrieves the index of a given many-body state within the Hilbert subspace. If a dictionary is available, it uses it for O(1) lookup; otherwise, it falls back to sorted list search. Returns 0 if the state is not found.\n\n\n\n\n\n","category":"method"},{"location":"EDCore/api/#EDCore.get_from_list","page":"API Reference","title":"EDCore.get_from_list","text":"get_from_list(space::HilbertSubspace{bits}, mbs::MBS64{bits})::Int64\n\nRetrieves the index of a given many-body state within the Hilbert subspace by searching the state list. This method does not use the dictionary, even if it exists. Returns 0 if the state is not found.\n\n\n\n\n\n","category":"function"},{"location":"EDCore/api/#EDCore.get_from_dict","page":"API Reference","title":"EDCore.get_from_dict","text":"get_from_dict(space::HilbertSubspace{bits}, mbs::MBS64{bits})::Int64\n\nRetrieves the index of a given many-body state within the Hilbert subspace using the pre-built dictionary. This method requires the dictionary to be non-empty. Returns 0 if the state is not found.\n\n\n\n\n\n","category":"function"},{"location":"EDCore/api/#Many-Body-Vector","page":"API Reference","title":"Many-Body Vector","text":"","category":"section"},{"location":"EDCore/api/#Types-3","page":"API Reference","title":"Types","text":"","category":"section"},{"location":"EDCore/api/#EDCore.MBS64Vector","page":"API Reference","title":"EDCore.MBS64Vector","text":"struct MBS64Vector{bits, F <: AbstractFloat}\n    vec::Vector{Complex{F}}\n    space::HilbertSubspace{bits}\nend\n\nA vector of components bounded to a HilbertSubspace that defines the space and basis. It represents a general many-body state in the basis of the given MBS64{bits} list.\n\nTo save the memory usage, use the same HilbertSubspace for all MBS64Vectors in the same subspace.\n\nConstructor:\n\nMBS64Vector(vec::Vector{Complex{F}}, space::HilbertSubspace{bits}) where {bits, F <: AbstractFloat}\n\nConstructs an MBS64Vector from a vector of complex coefficients and a HilbertSubspace. The length of the vector must match the dimension of the Hilbert subspace.\n\n\n\n\n\n","category":"type"},{"location":"EDCore/api/#Base.show-Union{Tuple{F}, Tuple{bits}, Tuple{IO, MIME{Symbol(\"text/plain\")}, MBS64Vector{bits, F}}} where {bits, F<:AbstractFloat}","page":"API Reference","title":"Base.show","text":"Base.show(io::IO, mime::MIME\"text/plain\", mbs_vec::MBS64Vector{bits, F}) where {bits, F <: AbstractFloat}\n\nDisplays a human-readable representation of the MBS64Vector, including its type parameters and the underlying vector.\n\n\n\n\n\n","category":"method"},{"location":"EDCore/api/#Functions-3","page":"API Reference","title":"Functions","text":"","category":"section"},{"location":"EDCore/api/#Base.length-Tuple{MBS64Vector}","page":"API Reference","title":"Base.length","text":"length(mbs_vec::MBS64Vector)\n\nReturns the length of the MBS64Vector.\n\n\n\n\n\n","category":"method"},{"location":"EDCore/api/#Base.size-Tuple{MBS64Vector}","page":"API Reference","title":"Base.size","text":"size(mbs_vec::MBS64Vector)\n\nReturns the size of the MBS64Vector as a tuple (length,).\n\n\n\n\n\n","category":"method"},{"location":"EDCore/api/#Base.similar-Tuple{MBS64Vector}","page":"API Reference","title":"Base.similar","text":"similar(mbs_vec::MBS64Vector{bits, F})::MBS64Vector{bits, F} where {bits, F <: AbstractFloat}\n\nCreates a new MBS64Vector with the same HilbertSubspace and element type, but with uninitialized contents.\n\n\n\n\n\n","category":"method"},{"location":"EDCore/api/#LinearAlgebra.dot-Union{Tuple{F}, Tuple{bits}, Tuple{MBS64Vector{bits, F}, MBS64Vector{bits, F}}} where {bits, F<:AbstractFloat}","page":"API Reference","title":"LinearAlgebra.dot","text":"dot(mbs_bra::MBS64Vector{bits, F}, mbs_ket::MBS64Vector{bits, F})::Complex{F}\nmbs_bra ⋅ mbs_ket\n\nComputes the dot product between two MBS64Vectors. Both vectors must belong to the same Hilbert subspace.\n\n\n\n\n\n","category":"method"},{"location":"EDCore/api/#Scattering-Term","page":"API Reference","title":"Scattering Term","text":"","category":"section"},{"location":"EDCore/api/#Types-4","page":"API Reference","title":"Types","text":"","category":"section"},{"location":"EDCore/api/#EDCore.Scatter","page":"API Reference","title":"EDCore.Scatter","text":"Scatter{N} - Represents an N-body Scatter term in the Hamiltonian\n\nFields:\n- Amp::ComplexF64: Scatter amplitude\n- out::NTuple{N, Int64}: Output orbital indices (creation operators)\n- in::NTuple{N, Int64}: Input orbital indices (annihilation operators)\n\n\n\n\n\n","category":"type"},{"location":"EDCore/api/#EDCore.NormalScatter","page":"API Reference","title":"EDCore.NormalScatter","text":"NormalScatter(V::ComplexF64, out_in::Int64...; upper_hermitian::Bool = false)::Scatter\n\nGenerate a scattering term with normal ordering. Optimized for N=1,2.\n\nterm: V * c†i1 c†i2 ... c†iN cjN ... cj2 cj1 (j-in, i-out )\n\n(1) j1 > j2 > ... > jN (no equality)\n(2) i1 > i2 > ... > iN (no equality)\nHermitian Upper Triangular:\n\n(3) j1 > i1 or j1 = i1 && j2 > i2 or j1,j2 = i1,i2 && j3 > i3 or ... or j1,...,jN-1 = i1,...,iN-1 && jN >= iN\n\nor equlivently in Julia's grammer\n\n(3') (j1,...,jN) >= (i1,...,iN)\n\nExample:\n\nNormalScatter(1.0+0.0im, 5, 3; upper_hermitian=true) == Scatter(-1.0+0.0im, 3, 5)\n\n\n\n\n\n","category":"function"},{"location":"EDCore/api/#EDCore.Scatter-Tuple{Any, Vararg{Int64}}","page":"API Reference","title":"EDCore.Scatter","text":"Scatter(V, out_in::Int64...)\n\nConstruct a Scatter term from amplitude and orbital indices.  However, it's recommemded to use NormalScatter for construction.\n\nThe constructor expects an even number of indices, where the first half are output indices (creation operators) and the second half are input indices (annihilation operators), in reverse order for proper normal ordering.\n\nArguments\n\nV::Number: Scatter amplitude (converted to ComplexF64)\nout_in::Int64...: Variable number of orbital indices (must be even)\n\nExamples\n\n# One-body: V * c†_i c_j\ns1 = Scatter(1.0, 1, 2)  # Creates c†_1 c_2 term\n\n# Two-body: V * c†_i1 c†_i2 c_j2 c_j1  \ns2 = Scatter(0.5, 1, 2, 4, 3)  # Creates c†_1 c†_2 c_4 c_3 term\n\n\n\n\n\n","category":"method"},{"location":"EDCore/api/#Base.show-Union{Tuple{N}, Tuple{IO, Scatter{N}}} where N","page":"API Reference","title":"Base.show","text":"Base.show(io::IO, st::Scatter{N})\n\nDisplay a scattering term in a readable format.\n\n\n\n\n\n","category":"method"},{"location":"EDCore/api/#Functions-4","page":"API Reference","title":"Functions","text":"","category":"section"},{"location":"EDCore/api/#EDCore.get_body","page":"API Reference","title":"EDCore.get_body","text":"get_body(::Scatter{N}) = N\n\nReturn number of body.\n\n\n\n\n\n","category":"function"},{"location":"EDCore/api/#EDCore.isnormal","page":"API Reference","title":"EDCore.isnormal","text":"docstring needed\n\n\n\n\n\n","category":"function"},{"location":"EDCore/api/#EDCore.isnormalupper","page":"API Reference","title":"EDCore.isnormalupper","text":"docstring needed\n\n\n\n\n\n","category":"function"},{"location":"EDCore/api/#EDCore.isdiagonal","page":"API Reference","title":"EDCore.isdiagonal","text":"isdiagonal(s::Scatter)::Bool\n\ns.in == s.out\n\n\n\n\n\n","category":"function"},{"location":"EDCore/api/#Base.adjoint-Union{Tuple{Scatter{N}}, Tuple{N}} where N","page":"API Reference","title":"Base.adjoint","text":"adjoint(s::Scatter{N})::Scatter{N}\n\nCreate a reverse scattering term: exchange incident and output orbitals and conjugate amplitude.\n\n\n\n\n\n","category":"method"},{"location":"EDCore/api/#Base.isless-Union{Tuple{N2}, Tuple{N1}, Tuple{Scatter{N1}, Scatter{N2}}} where {N1, N2}","page":"API Reference","title":"Base.isless","text":"isless(s1::Scatter{N1}, s2::Scatter{N2})::Bool\n\nIrrelevant to  amplitute, compare scattering types.\n\nN1 < N2; if equal, s1.in < s2.in; if equal, s1.out < s2.out.\n\n\n\n\n\n","category":"method"},{"location":"EDCore/api/#Base.:==-Union{Tuple{N2}, Tuple{N1}, Tuple{Scatter{N1}, Scatter{N2}}} where {N1, N2}","page":"API Reference","title":"Base.:==","text":"==(s1::Scatter{N1}, s2::Scatter{N2})::Bool\n\nIrrelevant to  amplitute, check if the scattering types are the same.\n\nN1 == N2, and s1.in == s2.in, and s1.out == s2.out.\n\n\n\n\n\n","category":"method"},{"location":"EDCore/api/#Base.:+-Union{Tuple{N}, Tuple{Scatter{N}, Scatter{N}}} where N","page":"API Reference","title":"Base.:+","text":"s1::Scatter{N} + s2::Scatter{N} -> sum::Scatter{N}\n\nCombine the amplitutes of the two terms of the same type. \n\n(N1 == N2) and s1.in == s2.in and s1.out == s2.out.\n\nReturn a scattering term with summing amplitute.\n\n\n\n\n\n","category":"method"},{"location":"EDCore/api/#Base.:*-Union{Tuple{N}, Tuple{Number, Scatter{N}}} where N","page":"API Reference","title":"Base.:*","text":"a::Number * s::Scatter{N} -> s'::Scatter{N}\n\nReturn a scattering term with amplitute multiplied a number.\n\nThe number should be able to converted as ComplexF64.\n\n\n\n\n\n","category":"method"},{"location":"EDCore/api/#EDCore.sort_merge_scatlist","page":"API Reference","title":"EDCore.sort_merge_scatlist","text":"sort_merge_scatlist(lists; keywords)\n\nSort and merge a list (lists) of normalized Scatter terms.\n\nInput\n\n(1) lists::Vector{Scatter{N}}:\n\nReturn a sorted and merged list: Vector{Scatter{N}}\n\n(2) lists::Vector{Scatter}:\n\nGrouping scattering terms by their N, then sorting and merging each group.  Return a list of sorted and merged lists: Vector{Vector{<: Scatter}}, each inner list has a specified N.\n\n(3) lists::Vector{Vector{<:Scatter}}:\n\nSimilar to (2). Return a list of sorted and merged lists: Vector{Vector{<: Scatter}}, each inner list has a specified N.\n\nKeywords\n\ncheck_normal::Bool = true: checking all the scatting terms are in nomal order\ncheck_normalupper::Bool = true: checking all the scatting terms are in nomal order and is in the upper triangular position.\n\n\n\n\n\n","category":"function"},{"location":"EDCore/api/#Many-Body-Operator","page":"API Reference","title":"Many-Body Operator","text":"","category":"section"},{"location":"EDCore/api/#Types-5","page":"API Reference","title":"Types","text":"","category":"section"},{"location":"EDCore/api/#EDCore.MBOperator","page":"API Reference","title":"EDCore.MBOperator","text":"struct MBOperator\n    scats::Vector{Vector{<:Scatter}}\n    upper_hermitian::Bool\nend\n\nRepresents a many-body operator as a list of lists of Scatter terms.\n\nFields\n\nscats::Vector{Vector{<:Scatter}}: A vector of vectors, where each inner vector contains Scatter{N} terms.\nupper_hermitian::Bool: Indicates whether the operator is upper Hermitian, affecting how terms are handled.\n\nIn the construction of operators, all Scatter terms are automatically reorganized by their body number. Terms of the same scatter-in and -out states are merged. Terms of the same body number are sorted\n\nConstructor\n\nMBOperator(scats::Vector{<: Scatter}...; upper_hermitian::Bool)\nMBOperator(scats::Vector{Vector{<:Scatter}}; upper_hermitian::Bool)\n\nConstructs an MBOperator from input Scatter terms. The upper_hermitian flag determines how scattering terms are sorted and merged.\n\n\n\n\n\n","category":"type"},{"location":"EDCore/api/#Base.show-Tuple{IO, MBOperator}","page":"API Reference","title":"Base.show","text":"Base.show(io::IO, op::MBOperator)\n\nDisplays a human-readable representation of the MBOperator, including its upper_hermitian status and the number of scattering terms.\n\n\n\n\n\n","category":"method"},{"location":"EDCore/api/#Functions-5","page":"API Reference","title":"Functions","text":"","category":"section"},{"location":"EDCore/api/#EDCore.isupper","page":"API Reference","title":"EDCore.isupper","text":"isupper(op::MBOperator)::Bool\n\nReturns true if the operator is upper Hermitian, false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"EDCore/api/#Base.adjoint-Tuple{MBOperator}","page":"API Reference","title":"Base.adjoint","text":"adjoint(op::MBOperator)::MBOperator\n\nComputes the adjoint of the operator op by creating a deep copy and then applying adjoint!.\n\n\n\n\n\n","category":"method"},{"location":"EDCore/api/#LinearAlgebra.adjoint!-Tuple{MBOperator}","page":"API Reference","title":"LinearAlgebra.adjoint!","text":"adjoint!(op::MBOperator)::MBOperator\n\nComputes the adjoint of the operator op in-place. If the operator is not upper Hermitian, it adjoints each scattering term.\n\n\n\n\n\n","category":"method"},{"location":"EDCore/api/#Multiplication-and-Bracket","page":"API Reference","title":"Multiplication and Bracket","text":"","category":"section"},{"location":"EDCore/api/#Functions-6","page":"API Reference","title":"Functions","text":"","category":"section"},{"location":"EDCore/api/#Base.:*-Tuple{Scatter, MBS64}","page":"API Reference","title":"Base.:*","text":"scat * (amp_in::ComplexF64, mbs_in::MBS64) -> (amp_out::ComplexF64, mbs_out::MBS64)\nscat * mbs_in::MBS64 = scat * (1.0, mbs_in)\n\nApplying a scatter operator on a many-body basis. Return the amplitute and the output many-body basis.\n\nThe amplitute is zero if no output state.\n\nNotice: this multiplication assumes scat is normal. Using abnormal Scatter term will generate same result as if its indices are sorted, which may cause a sign error. It is recommended to always use NormalScatter to create Scatter terms.\n\n\n\n\n\n","category":"method"},{"location":"EDCore/api/#Base.:*-Tuple{MBS64, Scatter}","page":"API Reference","title":"Base.:*","text":"(amp_out::ComplexF64, mbs_out::MBS64) * scat -> (amp_in::ComplexF64, mbs_in::MBS64)\nmbs_out::MBS64 * scat = (1.0, mbs_out) * scat\n\nApplying a scatter operator on a output many-body basis from the right. Return the amplitute and the incident many-body basis.\n\nThe amplitute is zero if no incident state.\n\nNotice: this multiplication assumes scat is normal. Using abnormal Scatter term will generate same result as if its indices are sorted, which may cause a sign error. It is recommended to always use NormalScatter to create Scatter terms.\n\n\n\n\n\n","category":"method"},{"location":"EDCore/api/#Base.:*-Tuple{MBOperator, MBS64Vector}","page":"API Reference","title":"Base.:*","text":"op::MBOperator * mbs_vec::MBS64Vector -> mbs_vec_result::MBS64Vector\nop2::MBOperator * op1::MBOperator * mbs_vec::MBS64Vector -> mbs_vec_result::MBS64Vector\n\nApplying one or two operators on a many-body state. More number of operators is not supported and should be implemented in steps.\n\n\n\n\n\n","category":"method"},{"location":"EDCore/api/#EDCore.ED_bracket","page":"API Reference","title":"EDCore.ED_bracket","text":"ED_bracket(mbs_vec_bra::MBS64Vector{bits, eltype}, \n    op::MBOperator, mbs_vec_ket::MBS64Vector{bits, eltype}\n    )::Complex{eltype} where {bits, eltype <: AbstractFloat}\nED_bracket(mbs_vec_bra::MBS64Vector{bits, eltype}, \n    op2::MBOperator, op1::MBOperator, mbs_vec_ket::MBS64Vector{bits, eltype}\n    )::Complex{eltype} where {bits, eltype <: AbstractFloat}\n\nCompute the bracket <bra::MBS64Vector | op::MBOperator | ket::MBS64Vector>\n\nor the bracket <bra::MBS64Vector | op2::MBOperator * op1::MBOperator | ket::MBS64Vector>\n\n\n\n\n\n","category":"function"},{"location":"EDCore/api/#EDCore.ED_bracket_threaded","page":"API Reference","title":"EDCore.ED_bracket_threaded","text":"ED_bracket_threaded(mbs_vec_bra::MBS64Vector{bits, eltype}, \n    op::MBOperator, mbs_vec_ket::MBS64Vector{bits, eltype}\n    )::Complex{eltype} where {bits, eltype <: AbstractFloat}\nED_bracket_threaded(mbs_vec_bra::MBS64Vector{bits, eltype}, \n    op2::MBOperator, op1::MBOperator, mbs_vec_ket::MBS64Vector{bits, eltype}\n    )::Complex{eltype} where {bits, eltype <: AbstractFloat}\n\n(Multithread version.) Compute the bracket <bra::MBS64Vector | op::MBOperator | ket::MBS64Vector>\n\nor the bracket <bra::MBS64Vector | op2::MBOperator * op1::MBOperator | ket::MBS64Vector>\n\n\n\n\n\n","category":"function"},{"location":"EDCore/api/#End","page":"API Reference","title":"End","text":"","category":"section"},{"location":"MomentumED/tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"MomentumED/tutorial/","page":"Tutorial","title":"Tutorial","text":"(Content to be added)","category":"page"},{"location":"MomentumED/api/#MomentumED-API-Reference","page":"API Reference","title":"MomentumED API Reference","text":"","category":"section"},{"location":"MomentumED/api/#MomentumED","page":"API Reference","title":"MomentumED","text":"This module gives general methods for 2D momentum-block-diagonalized ED calculations. Sectors of other quantum Numbers should be handled outside this module. This module only sets sectors of total (crystal) momentum, also called blocks.\n\nexport list\n\n# submodules\nexport EDCore\npublic Preparation, Methods, Analysis\n\n# main solving function\nexport EDsolve\n\n# from EDCore\nexport MBS64, NormalScatter, MBOperator\nexport HilbertSubspace, MBS64Vector, Scatter\npublic get_bits, get_body, make_dict!, delete_dict!\npublic isphysical, isupper, isnormal, isnormalupper, isdiagonal\nexport ED_bracket, ED_bracket_threaded\npublic ColexMBS64, ColexMBS64Mask\n\n# preparation\nexport EDPara, ED_momentum_subspaces\nexport ED_sortedScatterList_onebody\nexport ED_sortedScatterList_twobody\n\n# methods\npublic ED_HamiltonianMatrix_threaded, LinearMap\n\n# analysis - reduced density matrix for entanglement spectrum\nexport PES_1rdm, PES_MomtBlocks, PES_MomtBlock_rdm\nexport OES_NumMomtBlocks, OES_NumMomtBlock_coef\n\n# analysis - many-body connection\nexport ED_connection_step, ED_connection_gaugefixing!\n\n# environment variables\npublic PRINT_RECURSIVE_MOMENTUM_DIVISION\npublic PRINT_TWOBODY_SCATTER_PAIRS\n\n\n\n\n\n","category":"module"},{"location":"MomentumED/api/#Main-EDsolve-Function","page":"API Reference","title":"Main EDsolve Function","text":"","category":"section"},{"location":"MomentumED/api/#MomentumED.EDsolve","page":"API Reference","title":"MomentumED.EDsolve","text":"EDsolve(subspace::HilbertSubspace, hamiltonian; kwargs...) \n    -> energies::Vector, vectors::Vector{MBS64Vector}\n\nMain exact diagonalization solver for momentum-conserved quantum systems.\n\nThis function finds the lowest eigenvalues and eigenvectors of a Hamiltonian within a given momentum subspace. It supports multiple methods for diagonalization and can accept the Hamiltonian in two formats.\n\nArguments\n\nsubspace::HilbertSubspace: The Hilbert subspace for a specific momentum block, containing the basis states.\nhamiltonian: The Hamiltonian to be diagonalized. It can be provided in two forms:\nAs a series of sorted Vector{<:Scatter} arguments (e.g., EDsolve(subspace, scat1, scat2)). This form is used for matrix-based methods.\nAs a single MBOperator object (e.g., EDsolve(subspace, H_operator)). This form is required for the matrix-free :map method.\n\nKeyword Arguments\n\nN::Int64 = 6: The number of eigenvalues/eigenvectors to compute.\nmethod::Symbol = :sparse: The diagonalization method. Options are:\n:sparse: (Default) Constructs the Hamiltonian as a sparse matrix. Good for most cases.\n:dense: Constructs a dense matrix. Can be faster for very small systems.\n:map: Uses a matrix-free LinearMap approach. This is the most memory-efficient method for very large systems and requires the hamiltonian to be an MBOperator.\nelement_type::Type = Float64: The element type for the Hamiltonian matrix (for :sparse/:dense).\nindex_type::Type = Int64: The integer type for the sparse matrix indices (for :sparse).\nmin_sparse_dim::Int64 = 100: If method is :sparse but the dimension is smaller than this, it will automatically switch to :dense.\nmax_dense_dim::Int64 = 200: If method is :dense but the dimension is larger than this, it will automatically switch to :sparse.\nishermitian::Bool = true: Specifies if the Hamiltonian is Hermitian. This is passed to the eigensolver for optimization.\nshowtime::Bool = false: If true, prints the time taken for matrix construction and diagonalization.\nkrylovkit_kwargs...: Additional keyword arguments passed directly to KrylovKit.eigsolve.\n\nReturns\n\nenergies::Vector: A vector containing the N lowest eigenvalues.\nvectors::Vector{MBS64Vector}: A vector of the corresponding eigenvectors, wrapped in the MBS64Vector type.\n\nExamples\n\n1. Using Scatter Lists (Sparse Method):\n\nsubspaces, _, _ = ED_momentum_subspaces(para, (1,1))\nscat1 = ED_sortedScatterList_onebody(para)\nscat2 = ED_sortedScatterList_twobody(para)\n\n# Find the 2 lowest energy states\nenergies, vecs = EDsolve(subspaces[1], scat1, scat2; N=2, method=:sparse)\n\n2. Using MBOperator (Linear Map Method):\n\nH_op = MBOperator(scat1, scat2)\n# Find the 2 lowest energy states using the matrix-free approach\nenergies, vecs = EDsolve(subspaces[1], H_op; N=2, method=:map)\n\n\n\n\n\n","category":"function"},{"location":"MomentumED/api/#Preparation","page":"API Reference","title":"Preparation","text":"","category":"section"},{"location":"MomentumED/api/#MomentumED.Preparation","page":"API Reference","title":"MomentumED.Preparation","text":"This module provides methods of defining a system for calculation. Many functions assume the system has at most two-body symmetric interaction, Hermitian Hamiltonian, and momentum conservation.\n\n\n\n\n\n","category":"module"},{"location":"MomentumED/api/#MomentumED.Preparation.EDPara","page":"API Reference","title":"MomentumED.Preparation.EDPara","text":"mutable struct EDPara\n\nStores all parameters for a momentum-conserved exact diagonalization calculation.\n\nConstructor\n\nEDPara(; \n    Gk::Tuple{Int64, Int64} = (0, 0), \n    k_list::Matrix{Int64},\n    Nc_hopping::Int64 = 1,\n    Nc_conserve::Int64 = 1,\n    H_onebody::Array{ComplexF64,4} = zeros(ComplexF64, Nc_hopping, Nc_hopping, Nc_conserve, size(k_list, 2)),\n    V_int::Function = (kf1, kf2, ki1, ki2, cf1, cf2, ci1, ci2) -> 0.0 + 0.0im,\n    FF_inf_angle::Function = (k_f, k_i, c) -> 0.0\n)\n\nKeyword Arguments\n\nk_list::Matrix{Int64}: Required. A matrix where each column k_list[:, i] represents a momentum vector (k_x, k_y).\nGk::Tuple{Int64, Int64} = (0, 0): The reciprocal lattice vectors (G1, G2). Momentum is conserved modulo Gk. A value of 0 means no periodicity in that direction.\nNc_hopping::Int64 = 1: The number of \"hopping\" components whose particle numbers are not conserved.\nNc_conserve::Int64 = 1: The number of components where the particle number is conserved (e.g., valley).\nH_onebody::Array{ComplexF64,4}: The one-body part of the Hamiltonian. Defaults to zeros.\nV_int::Function: A function defining the two-body interaction potential. See \"Interaction Function\" below. Defaults to a function that returns zero.\nFF_inf_angle::Function: A function defining the Berry connection for infinitesimal transformations. See \"Berry Connection Function\" below. Defaults to a function that returns zero.\n\nFields (in addition to keyword arguments)\n\nNk::Int64: The number of momentum states, derived from size(k_list, 2).\nNc::Int64: The total number of components, Nc_hopping * Nc_conserve.\nmomentum_coordinate::Bool: A flag that is automatically set to true if V_int accepts momentum coordinates (Tuple{Float64,Float64}), and false if it accepts momentum indices (Int64).\n\nInteraction Function (V_int)\n\nThe V_int function must accept 8 arguments and return a ComplexF64.  V_int(kf1, kf2, ki2, ki1, cf1::Int64, cf2::Int64, ci2::Int64, ci1::Int64) -> ComplexF64. Input momenta can have one of two signatures:\n\nCoordinate-based: ki and kf are momentum coordinates as Tuple{<:Real, <:Real}.\nIndex-based: ki and kf are momentum indices as Int64, refering to the momenta in k_list.\n\nThe constructor automatically detects which signature is used.\n\nBerry Connection Function (FF_inf_angle)\n\nThe FF_inf_angle function must accept 3 arguments (k_f, k_i, c) and return a Float64. k_f and k_i are momentum coordinates.\n\nOrbital Indexing\n\nThe single orbital index i is mapped from a multi-index (i_k, i_ch, i_cc) as follows: i = i_k + Nk * (i_ch - 1) + (Nk * Nc_hopping) * (i_cc - 1) where i_k is the momentum index, i_ch is the hopping component index, and i_cc is the conserved component index.\n\nValidation\n\nThe total number of orbitals (Nk * Nc) must not exceed 64.\nThe provided V_int and FF_inf_angle functions must conform to one of the valid signatures.\n\n\n\n\n\n","category":"type"},{"location":"MomentumED/api/#MomentumED.Preparation.ED_momentum_subspaces-Tuple{EDPara, Any}","page":"API Reference","title":"MomentumED.Preparation.ED_momentum_subspaces","text":"ED_momentum_subspaces(para::EDPara, N_each_component; kwargs...) -> Tuple{Vector{HilbertSubspace}, Vector{Int64}, Vector{Int64}}\n\nConstructs Hilbert subspaces, each corresponding to a specific total momentum.\n\nThis is the main user-facing function to generate the basis states for a momentum-conserved calculation. It orchestrates the construction of many-body states by calling the recursive helper function mbslist_recursive_iteration!. The resulting states are partitioned into HilbertSubspace objects, each containing all states with a specific total momentum (K1, K2).\n\nArguments\n\npara::EDPara: The parameter object containing system details like momentum vectors and component info.\nN_each_component: A tuple or vector specifying the number of particles in each conserved component. The sign of the number has a special meaning:\nPositive N: Represents N particles.\nNegative N: Represents abs(N) holes in a fully filled band. This is useful for certain calculations like the particle reduced density matrix (see MomentumED/src/analysis/particle_reduced_density_matrix.jl).\n\nKeyword Arguments\n\ndict::Bool = false: If true, a dictionary mapping each state to its index is created within each HilbertSubspace.\nindex_type::Type = Int64: The integer type for the dictionary indices.\nmomentum_restriction::Bool = false: If true, only generate subspaces for momenta specified by k1range, k2range, or momentum_list.\nk1range::Tuple{Int64, Int64}: The range of k1 total momentum to generate.\nk2range::Tuple{Int64, Int64}: The range of k2 total momentum to generate.\nmomentum_list::Vector{Tuple{Int64, Int64}}: A list of specific (K1, K2) total momenta to generate.\nmask::Union{Nothing, Vector{Int64}} = nothing: Restricts the set of available single-particle orbitals for the first component processed by the recursive algorithm. For positive N, only orbitals in the mask are occupied. For negative N, holes are created only from orbitals in the mask.\n\nReturns\n\nsubspaces::Vector{HilbertSubspace}: A vector of Hilbert subspaces. Each element contains a list of MBS64 states belonging to a specific momentum.\nsubspace_k1::Vector{Int64}: A vector where subspace_k1[i] is the k1 momentum of subspaces[i].\nsubspace_k2::Vector{Int64}: A vector where subspace_k2[i] is the k2 momentum of subspaces[i].\n\nExample\n\npara = EDPara(k_list=[0 1; 0 0], Nc_conserve=2)\n# Generate subspaces for a system with 1 particle in the first component and 2 in the second\nsubspaces, subspace_k1, subspace_k2 = ED_momentum_subspaces(para, (1, 2))\n\n\n\n\n\n","category":"method"},{"location":"MomentumED/api/#MomentumED.Preparation.ED_sortedScatterList_onebody-Tuple{EDPara}","page":"API Reference","title":"MomentumED.Preparation.ED_sortedScatterList_onebody","text":"ED_sortedScatterList_onebody(para::EDPara) -> Vector{Scatter{1}}\n\nGenerate sorted lists of one-body Scatter terms from the parameters.\n\nExtracts one-body terms from EDpara.H_onebody for multi-component systems and converts them to Scatter terms with proper normal ordering.\n\nArguments\n\npara::EDPara: Parameter structure containing system configuration\n\nReturns\n\nVector{Scatter{1}}: Sorted list of one-body Scatter terms\n\nDetails\n\nMaps component indices to global orbital indices using: global_index = k + Nk * (ch - 1) + Nk * Nch * (cc - 1)\nApplies normal ordering to avoid double-counting\nUses sort_merge_scatlist to eliminate duplicates and sort terms\nOnly includes non-zero amplitude terms\n\nExample\n\npara = EDPara(k_list=k_list, Gk=(3, 5), V_int=V_int)\nScatter1 = ED_sortedScatterList_onebody(para)\n\n\n\n\n\n","category":"method"},{"location":"MomentumED/api/#MomentumED.Preparation.ED_sortedScatterList_twobody-Tuple{EDPara}","page":"API Reference","title":"MomentumED.Preparation.ED_sortedScatterList_twobody","text":"ED_sortedScatterList_twobody(para::EDPara; kshift=nothing) -> Vector{Scatter{2}}\n\nGenerate a sorted list of two-body Scatter terms from the interaction potential.\n\nThis function orchestrates the generation of all two-body scattering terms. It first groups momentum pairs by their total momentum to ensure conservation, then calls the appropriate internal function (scat_pair_group_coordinate or scat_pair_group_index) based on the signature of the interaction potential para.V_int.\n\nArguments\n\npara::EDPara: The parameter structure containing system configuration, including the V_int function.\n\nKeywords\n\nkshift=nothing: Specifies a momentum shift for twisted boundary conditions. This is only applicable if para.V_int accepts momentum coordinates. The value can be:\nnothing (default): No shift.\nTuple{Real, Real}: A uniform shift (kx, ky) applied to all conserved components.\nVector{Tuple{Real, Real}}: A specific shift for each conserved component.\nMatrix{Real}: A 2 x Nc_conserve matrix specifying the shift for each component.\n\nReturns\n\nVector{Scatter{2}}: A sorted and merged list of all unique two-body Scatter terms.\n\nDetails\n\nAutomatically detects whether para.V_int uses momentum coordinates or indices.\nIf using indices, kshift is ignored.\nThe final list is processed by sort_merge_scatlist to eliminate duplicates and sort the terms.\n\nExample\n\npara = EDPara(k_list=k_list, Gk=(3, 5), V_int=V_int)\n# Generate with no momentum shift\nScatter2 = ED_sortedScatterList_twobody(para)\n# Generate with a uniform twisted boundary condition\nScatter2_shifted = ED_sortedScatterList_twobody(para; kshift=(0.1, 0.1))\n\n\n\n\n\n","category":"method"},{"location":"MomentumED/api/#MomentumED.Preparation.MBS_totalmomentum-Tuple{EDPara, Vararg{Int64}}","page":"API Reference","title":"MomentumED.Preparation.MBS_totalmomentum","text":"MBS_totalmomentum(para::EDPara, i_list::Int64...)\n\nCalculate the total momentum (K1, K2) from a list of occupied orbital indices.\n\n\n\n\n\n","category":"method"},{"location":"MomentumED/api/#MomentumED.Preparation.MBS_totalmomentum-Tuple{Matrix{Int64}, Tuple{Int64, Int64}, MBS64}","page":"API Reference","title":"MomentumED.Preparation.MBS_totalmomentum","text":"MBS_totalmomentum(para::EDPara, mbs::MBS64)\n\nCalculate the total momentum (K1, K2) of a many-body state. The momentum is mod G if G is nonzero (from para.Gk).\n\n\n\n\n\n","category":"method"},{"location":"MomentumED/api/#MomentumED.Preparation.group_momentum_pairs-Tuple{EDPara}","page":"API Reference","title":"MomentumED.Preparation.group_momentum_pairs","text":"group_momentum_pairs(para::EDPara) -> Dict{Tuple{Int64,Int64}, Vector{Tuple{Int64,Int64}}}\n\nGenerate grouped momentum pairs by their total momentum.\n\nCreates a dictionary mapping total momentum quantum numbers to lists of  momentum index pairs that conserve that total momentum.\n\nArguments\n\npara::EDPara: Parameter structure containing system configuration\n\nReturns\n\nDict{Tuple{Int64,Int64}, Vector{Tuple{Int64,Int64}}}: Dictionary where:\nKeys are total momentum tuples (K1, K2)\nValues are vectors of momentum index pairs [(i,j), ...] with that total momentum\n\nDetails\n\nGenerates all possible pairs (i,j) with i >= j to avoid duplicates\nUses MBS_totalmomentum(para, i, j) to compute total momentum for each pair\nEssential for efficient two-body Scatter term generation\nEnables momentum conservation enforcement in Hamiltonian construction\n\nExample\n\npara = EDPara(k_list=k_list, Gk=(3, 5), V_int=V_int)\ngroups = group_momentum_pairs(para)\n# Access all pairs with total momentum (0, 0)\npairs_with_zero_momentum = groups[(0, 0)]\n\n\n\n\n\n","category":"method"},{"location":"MomentumED/api/#MomentumED.Preparation.mbslist_onecomponent-Tuple{EDPara, Int64}","page":"API Reference","title":"MomentumED.Preparation.mbslist_onecomponent","text":"mbslist_onecomponent(para::EDPara, N_in_one::Int64[, mask])\n\nConstruct the MBS list(iterator) of N electrons in one conserved component.\n\nGenerates all possible MBS64 states with exactly Ninone particles in the specified component, using combinations of orbital indices.\n\nArguments\n\npara::EDPara: Parameter structure containing momentum and component information\nN_in_one::Int64: Number of particles in the conserved component\n\nReturns\n\nIterator{MBS64}: Sorted list of MBS64 states with specified particle number\n\nExample\n\npara = EDPara(k_list=[0 1; 0 0], Nc_hopping=1, Nc_conserve=1)\nstates = ED_mbslist_onecomponent(para, 2)  # 2 particles in 2 orbitals\n\n\n\n\n\n","category":"method"},{"location":"MomentumED/api/#MomentumED.Preparation.mbslist_recursive_iteration!-Union{Tuple{bits}, Tuple{Array{HilbertSubspace{bits}, 1}, Vector{Int64}, Vector{Int64}, EDPara, Vector{Int64}}, Tuple{Array{HilbertSubspace{bits}, 1}, Vector{Int64}, Vector{Int64}, EDPara, Vector{Int64}, MBS64}, Tuple{Array{HilbertSubspace{bits}, 1}, Vector{Int64}, Vector{Int64}, EDPara, Vector{Int64}, MBS64, Tuple{Int64, Int64}}} where bits","page":"API Reference","title":"MomentumED.Preparation.mbslist_recursive_iteration!","text":"mbslist_recursive_iteration!(subspaces, subspace_k1, subspace_k2, para, N_each_component, accumulated_mbs, accumulated_momentum; mask=nothing)\n\nAn internal recursive function that constructs many-body states and sorts them into momentum subspaces.\n\nThe function works by processing one conserved component at a time. It iterates through all valid states for the current component and then calls itself recursively for the next component, accumulating the state (MBS64) and total momentum.\n\nRecursion Logic\n\nThe recursion proceeds from the last element of N_each_component to the first. In each step, it generates all possible states for the current component based on the particle number abs(N_each_component[end]) and combines them (via *) with the accumulated_mbs from the previous steps. The momentum is also updated.\n\nWhen the recursion is complete (N_each_component is empty), the final state and its total momentum are known, and the state is pushed into the correct momentum subspace in subspaces.\n\nParticle vs. Hole Creation\n\nThe sign of the number in N_each_component determines whether particles or holes are created:\n\nPositive N: Creates N particles in an empty sea of orbitals for the current component.\nNegative N: Creates abs(N) holes in a filled sea of orbitals. This is used for calculations like the particle reduced density matrix where one considers states in the complementary space.\n\nKeywords\n\nThe mask argument, if provided, restricts the set of orbitals that can be occupied (for positive N) or made into holes (for negative N) for the single-component states. mask is a Vector{Int64} and must be sorted.\n\ncheck_mask_sorted::Bool=false will assert mask is sorted if it's provided.  It will only check once at the begining of outermost iteration.\n\n\n\n\n\n","category":"method"},{"location":"MomentumED/api/#MomentumED.Preparation.scat_pair_group_coordinate-Union{Tuple{T}, Tuple{Vector{Tuple{Int64, Int64}}, EDPara}} where T<:Real","page":"API Reference","title":"MomentumED.Preparation.scat_pair_group_coordinate","text":"scat_pair_group_coordinate(pair_group, para, shifts) -> Vector{Scatter{2}}\n\nGenerate all Scatter terms between momentum pairs with the same total momentum. This internal function uses an interaction function V_int that accepts momentum coordinates.\n\nArguments\n\npair_group::Vector{Tuple{Int64,Int64}}: List of momentum index pairs with the same total momentum.\npara::EDPara: Parameter structure containing system configuration.\nshifts::Matrix{<:Real}: A matrix of size (2, Nc_conserve) specifying the momentum shifts (twisted boundary conditions) for each conserved component.\n\nReturns\n\nVector{Scatter{2}}: A list of two-body Scatter terms for this momentum group.\n\nDetails\n\nIterates over all input/output momentum pair combinations within the group.\nGenerates all component index combinations for each momentum pair.\nMaps momentum and component indices to global orbital indices.\nApplies normal ordering: minmax(i1, i2) >= minmax(f1, f2).\nCalculates Scatter amplitudes using para.V_int with momentum shifts.\nIncludes both direct (V(f1,f2,i2,i1)) and exchange (V(f1,f2,i1,i2)) contributions.\n\n\n\n\n\n","category":"method"},{"location":"MomentumED/api/#MomentumED.Preparation.scat_pair_group_index-Tuple{Vector{Tuple{Int64, Int64}}, EDPara}","page":"API Reference","title":"MomentumED.Preparation.scat_pair_group_index","text":"scat_pair_group_index(pair_group, para) -> Vector{Scatter{2}}\n\nGenerate all Scatter terms between momentum pairs with the same total momentum. This internal function uses an interaction function V_int that accepts momentum indices.\n\nArguments\n\npair_group::Vector{Tuple{Int64,Int64}}: List of momentum index pairs with the same total momentum.\npara::EDPara: Parameter structure containing system configuration.\n\nReturns\n\nVector{Scatter{2}}: A list of two-body Scatter terms for this momentum group.\n\nDetails\n\nThis function is used when para.V_int expects integer indices instead of coordinates.\nIt does not handle momentum shifts (twisted boundary conditions); the para object itself should be updated if necessary.\nIterates over all input/output momentum pair combinations within the group.\nApplies normal ordering and calculates direct and exchange amplitudes.\n\n\n\n\n\n","category":"method"},{"location":"MomentumED/api/#Methods","page":"API Reference","title":"Methods","text":"","category":"section"},{"location":"MomentumED/api/#MomentumED.Methods","page":"API Reference","title":"MomentumED.Methods","text":"This module provides methods of generating Hamiltonian sparse matrix or Hamiltonian linear map, and use KrylovKit to solve them.\n\n\n\n\n\n","category":"module"},{"location":"MomentumED/api/#MomentumED.Methods.ED_HamiltonianMatrix_threaded-Tuple{HilbertSubspace, Vararg{Vector{<:Scatter}}}","page":"API Reference","title":"MomentumED.Methods.ED_HamiltonianMatrix_threaded","text":"ED_HamiltonianMatrix_threaded(sorted_mbs_block_list, sorted_scat_lists...)\n\nThreaded version of generating Hamiltonian Matrix with pre-computed state mapping and COO format construction.\n\nArguments\n\nsorted_mbs_block_list::Vector{<: MBS64}: Sorted basis states for momentum block\nsorted_scat_lists::Vector{<: Scatter}: lists of Scatter terms (one-body, two-body, etc.)\n\nKeywords\n\nelement_type::Type=Float64: Element type of the sparse matrix (Float64, Float32, Float16)\nindex_type::Type=Int64: Index type of the sparse matrix (Int64, Int32, Int16, Int8)\n\nReturns\n\nSparseMatrixCSC: Sparse Hamiltonian matrix\n\nNotes\n\nUses COO format construction with thread-local storage for better parallel performance. Provides 4-8x speedup for medium to large systems compared to the one-thread version.\n\n\n\n\n\n","category":"method"},{"location":"MomentumED/api/#MomentumED.Methods.krylov_map_solve-Union{Tuple{eltype}, Tuple{bits}, Tuple{MomentumED.Methods.LinearMap{bits, eltype}, Int64}} where {bits, eltype<:AbstractFloat}","page":"API Reference","title":"MomentumED.Methods.krylov_map_solve","text":"krylov_map_solve(H::SparseMatrixCSC{ComplexF64, Int64}, N_eigen::Int64=6; \n    converge_warning::Bool=false, krylovkit_kwargs...) -> (vals, vecs)\n\nSolve the sparse Hamiltonian matrix using KrylovKit's eigsolve function for the lowest N_eigen eigenvalues and eigenvectors.\n\nArguments\n\nH::SparseMatrixCSC{Complex{eltype}, idtype}: Sparse Hamiltonian matrix to diagonalize\nN_eigen::Int64=6: Number of eigenvalues/eigenvectors to compute (default: 6)\n\nKeywords\n\nvec0::Vector{Complex{eltype}}=rand(Complex{eltype}, H.m): Initial guess vector for Krylov iteration\nishermitian::Bool=true: Whether the matrix is Hermitian (default: true)\nkrylovkit_kwargs...: Additional keyword arguments to pass to KrylovKit.eigsolve\n\nReturns\n\nvals::Vector{eltype}: Eigenvalues (energies) in ascending order\nvecs::Vector{Vector{Complex{eltype}}}: Corresponding eigenvectors\ninfo: Convergence information from KrylovKit\n\nExamples\n\n# Solve for 3 lowest eigenstates\nvals, vecs, info = krylov_map_solve(H_map, 3)\nprintln(\"Ground state energy: \", vals[1])\n\nNotes\n\nUses KrylovKit's eigsolve with :SR (smallest real) eigenvalue selection\nAssumes Hermitian matrix (standard for quantum Hamiltonians)\nRandom initial vector ensures good convergence properties\nAutomatically handles convergence warnings from KrylovKit\nFor better control over convergence, consider using KrylovKit directly\n\n\n\n\n\n","category":"method"},{"location":"MomentumED/api/#MomentumED.Methods.krylov_matrix_solve-Union{Tuple{eltype}, Tuple{SparseArrays.SparseMatrixCSC{Complex{eltype}}, Int64}} where eltype<:AbstractFloat","page":"API Reference","title":"MomentumED.Methods.krylov_matrix_solve","text":"krylov_matrix_solve(H::SparseMatrixCSC{ComplexF64, Int64}, N_eigen::Int64=6; \n    converge_warning::Bool=false, krylovkit_kwargs...) -> (vals, vecs)\n\nSolve the sparse Hamiltonian matrix using KrylovKit's eigsolve function for the lowest N_eigen eigenvalues and eigenvectors.\n\nArguments\n\nH::SparseMatrixCSC{Complex{eltype}, idtype}: Sparse Hamiltonian matrix to diagonalize\nN_eigen::Int64=6: Number of eigenvalues/eigenvectors to compute (default: 6)\n\nKeywords\n\nvec0::Vector{Complex{eltype}}=rand(Complex{eltype}, H.m): Initial guess vector for Krylov iteration\nishermitian::Bool=true: Whether the matrix is Hermitian (default: true)\nkrylovkit_kwargs...: Additional keyword arguments to pass to KrylovKit.eigsolve\n\nReturns\n\nvals::Vector{eltype}: Eigenvalues (energies) in ascending order\nvecs::Vector{Vector{Complex{eltype}}}: Corresponding eigenvectors\ninfo: Convergence information from KrylovKit\n\nExamples\n\n# Solve for 3 lowest eigenstates\nvals, vecs, info = krylov_matrix_solve(H_matrix, 3)\nprintln(\"Ground state energy: \", vals[1])\n\nNotes\n\nUses KrylovKit's eigsolve with :SR (smallest real) eigenvalue selection\nAssumes Hermitian matrix (standard for quantum Hamiltonians)\nRandom initial vector ensures good convergence properties\nAutomatically handles convergence warnings from KrylovKit\nFor better control over convergence, consider using KrylovKit directly\n\n\n\n\n\n","category":"method"},{"location":"MomentumED/api/#Analysis","page":"API Reference","title":"Analysis","text":"","category":"section"},{"location":"MomentumED/api/#MomentumED.Analysis","page":"API Reference","title":"MomentumED.Analysis","text":"This module provides methods to analysis the ED eigenwavefunctions, including generating particle(hole)/orbital reduced density matrix for entanglement spectrum analysis,  and many-body connection analysis with momentum shifts\n\n\n\n\n\n","category":"module"},{"location":"MomentumED/api/#MomentumED.Analysis.ED_connection_gaugefixing!","page":"API Reference","title":"MomentumED.Analysis.ED_connection_gaugefixing!","text":"Modify the overall phase of eigenvectors. This is a preparation for many-body connection Wilson loop integral.\n\n\n\n\n\n","category":"function"},{"location":"MomentumED/api/#MomentumED.Analysis.ED_connection_step-Union{Tuple{MbsVec}, Tuple{MbsVec, MbsVec, Tuple{Float64, Float64}, Tuple{Float64, Float64}, EDPara}} where MbsVec<:MBS64Vector","page":"API Reference","title":"MomentumED.Analysis.ED_connection_step","text":"ED_connection_step(mbs_list::Vector{MBS64}, ψ_f::Vector{ComplexF64}, ψ_i::Vector{ComplexF64},\n                   shift_f::Tuple{Float64, Float64}, shift_i::Tuple{Float64, Float64},\n                   para::EDPara; wavefunction_tol::Float64=1e-8, amp_warn_tol::Float64=0.6,\n                   amp_warn::Bool=true)\n\nCompute the many-body Berry connection integral between two kshift points in momentum space.\n\nArguments\n\nmbs_list::Vector{MBS64}: List of many-body states in this momentum block\nψ_f::Vector{ComplexF64}: Eigenvector at shift_f\nψ_i::Vector{ComplexF64}: Eigenvector at shift_i\nshift_f::Tuple{Float64, Float64}: Final momentum shift\nshift_i::Tuple{Float64, Float64}: Initial momentum shift\npara::EDPara: ED parameters containing momentum states and system details\n\nKeywords\n\nwavefunction_tol::Float64=1e-8: Minimum amplitude in eigenvectors to consider\namp_warn_tol::Float64=0.6: Minimum inner product amplitude to avoid numerical instability warning\namp_warn::Bool=true: Whether to issue a warning for small inner product amplitude\n\nReturns\n\nFloat64: Step integral of many-body connection = arg( ⟨ψ2|ψ1⟩ )\n\nDescription\n\nThe many-body Berry connection step integral is computed as the phase of the inner product For small twist difference δshift = shiftf - shifti, inner product ⟨ψ2|ψ1⟩ ≈ exp(i * ∫ A ⋅ δshift) Step integral = arg(⟨ψ2|ψ1⟩)\n\n\n\n\n\n","category":"method"},{"location":"MomentumED/api/#MomentumED.Analysis.OES_NumMomtBlock_coef-Union{Tuple{F}, Tuple{bits}, Tuple{EDPara, MBS64Vector{bits, F}, Tuple{Real, Real}, Array{HilbertSubspace{bits}, 1}, Array{HilbertSubspace{bits}, 1}, Vector{Tuple{Int64, Int64}}, Vector{Tuple{Int64, Int64}}}} where {bits, F<:AbstractFloat}","page":"API Reference","title":"MomentumED.Analysis.OES_NumMomtBlock_coef","text":"docstring needed.\n\n\n\n\n\n","category":"method"},{"location":"MomentumED/api/#MomentumED.Analysis.OES_NumMomtBlocks-Tuple{EDPara, Any, Union{Tuple{Vararg{Int64}}, Vector{Int64}}}","page":"API Reference","title":"MomentumED.Analysis.OES_NumMomtBlocks","text":"docstring needed\n\n\n\n\n\n","category":"method"},{"location":"MomentumED/api/#MomentumED.Analysis.PES_1rdm-Union{Tuple{MBS64Vector{bits, F}}, Tuple{F}, Tuple{bits}} where {bits, F<:AbstractFloat}","page":"API Reference","title":"MomentumED.Analysis.PES_1rdm","text":"Simple way of generating one-body reduced density.\n\n\n\n\n\n","category":"method"},{"location":"MomentumED/api/#MomentumED.Analysis.PES_MomtBlock_rdm-Union{Tuple{F}, Tuple{bits}, Tuple{EDPara, MBS64Vector{bits, F}, HilbertSubspace{bits}}, Tuple{EDPara, MBS64Vector{bits, F}, HilbertSubspace{bits}, BitVector}} where {bits, F<:AbstractFloat}","page":"API Reference","title":"MomentumED.Analysis.PES_MomtBlock_rdm","text":"\n\n\n\n","category":"method"},{"location":"EDCore/tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"EDCore/tutorial/","page":"Tutorial","title":"Tutorial","text":"(Content to be added)","category":"page"},{"location":"EDCore/manual/#Manual","page":"Manual","title":"Manual","text":"","category":"section"},{"location":"EDCore/manual/","page":"Manual","title":"Manual","text":"(Content to be added)","category":"page"},{"location":"#MomentumED.jl","page":"Home","title":"MomentumED.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Julia package for momentum-conserved exact diagonalization of quantum many-body systems.","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This project provides a powerful and flexible framework for exact diagonalization (ED) of quantum many-body systems, with a special focus on 2D systems where momentum is a conserved quantity. The project is organized into two main packages:","category":"page"},{"location":"","page":"Home","title":"Home","text":"EDCore.jl: A lightweight, dependency-free core library that provides the fundamental building blocks for generic ED calculations. It defines abstract representations for many-body states (MBS64, MBS64Vector), operators (Scatter, MBOperator), and Hilbert subspaces (HilbertSubspace).\nMomentumED.jl: A high-level application package that uses EDCore.jl to implement specialized tools for momentum-conserved systems. It provides functions to set up system parameters, generate momentum-block-diagonal Hamiltonians, solve for eigenstates, and perform post-calculation analysis. It is made with the assumptions that the interaction is symmetric in switching the two vertices and that the Hamiltonian is hermitian and momentum-conserving; if you are doing a specific problem that fails to fit in these assumptions, consider making your dedicated initiating process using EDCore.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"MomentumED.jl uses KrylovKit.jl to diagonalize the Hamiltonian and find the eigenvalues and eigenvectors.","category":"page"},{"location":"","page":"Home","title":"Home","text":"MomentumED.jl also provides many-body state analysis methods to compute one-body reduced density matrix, many-body connection and many-body Chern number (NTW invariant), and particle-/orbital- reduced density matrix, entanglement entropy.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"#EDCore.jl-(Core-Library)","page":"Home","title":"EDCore.jl (Core Library)","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Bit-based State Representation: MBS64{bits} for efficient representation of many-body states in up to 64-orbital systems.\nGeneric Operator Algebra: Scatter{N} and MBOperator types for constructing and manipulating N-body operators.\nAbstract Hilbert Space: HilbertSubspace and MBS64Vector to manage basis states and eigenvectors.","category":"page"},{"location":"#MomentumED.jl-(High-Level-Application)","page":"Home","title":"MomentumED.jl (High-Level Application)","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Momentum-Space ED: Tools to build and solve Hamiltonians that are block-diagonal in total momentum.\nSystem Setup: The EDPara struct to easily configure system parameters like the k-list, interaction potential, and component structure.\nAutomated Basis Generation: ED_momentum_subspaces function to automatically generate basis states for each momentum sector.\nHamiltonian Construction: ED_sortedScatterList_... functions to generate one- and two-body operators from the system parameters.\nEigensolver: A simple EDsolve interface that wraps KrylovKit.jl for efficient sparse diagonalization.\nMany-Body Analysis: Built-in functions for calculating one-body reduced density matrices, particle/orbital entanglement spectrum, and many-body Berry connection.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This project contains two packages: EDCore and MomentumED. Since they are not yet registered and MomentumED depends on the local version of EDCore, the installation process requires you to clone the repository first.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Clone the repository:  sh  git clone https://github.com/Zou-Bo/MomentumED.jl  cd MomentumED.jl\nInstall the local packages:  Start Julia in the MomentumED.jl directory. Press ] to enter the package manager, then run:  julia  pkg> dev ./EDCore  pkg> dev ./MomentumED  This will install the packages from their local subdirectories, allowing Julia to correctly resolve the dependency between them.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Once the packages are registered in the Julia General Registry, you will be able to install them simply with Pkg.add(\"MomentumED\").","category":"page"},{"location":"#Structure-and-Dependency","page":"Home","title":"Structure and Dependency","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The project is organized into two main packages:","category":"page"},{"location":"","page":"Home","title":"Home","text":"EDCore/: The core library providing generic, low-level ED tools.\nEDCore/src/types/: Defines core data structures like MBS64, MBS64Vector, Scatter, MBOperator, and HilbertSubspace.\nEDCore/src/EDCore.jl: Implements the core functionalities and operator algebra.\nMomentumED/: The high-level package for momentum-space ED.\nMomentumED/src/preparation/: Functions for setting up calculations (parameter initialization, basis generation).\nMomentumED/src/method/: Hamiltonian construction and eigensolving methods.\nMomentumED/src/analysis/: Functions for post-calculation analysis (RDM, Berry connection, etc.).","category":"page"},{"location":"","page":"Home","title":"Home","text":"The dependency tree for the packages is as follows:","category":"page"},{"location":"","page":"Home","title":"Home","text":"MomentumED\n├── EDCore\n│   ├── LinearAlgebra\n│   └── Combinatorics\n├── KrylovKit\n├── LinearAlgebra\n└── SparseArrays","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package provides these main functions:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using MomentumED\n\n# Define k-mesh for 2D system\nk_list = [0 1 2 0 1 2 0 1 2 0 1 2 0 1 2;\n          0 0 0 1 1 1 2 2 2 3 3 3 4 4 4]\nGk = (3, 5) # momenta mod Gk are conserved\n\n# Example system with one compotent\nNc_hopping = 1 # default number if not being configured explcitly\nNc_conserve = 1 # default number if not being configured explcitly\n\n# Define one-body Hamiltonian (4-dim array)\nH0 = ComplexF64[ #= Your Hamiltonian elements here =# \n  cospi(2 * k_list[1, k] / Gk[1]) + cospi(2 * k_list[2, k] / Gk[2]) # Simple band dispersion\n  for ch_out in 1:Nc_hopping, ch_in in 1:Nc_hopping, cc in 1:Nc_conserve, k in axes(k_list, 2)\n]\n\n# Define interaction function, giving the amplitude before c†_{f1} c†_{f2} c_{i2} c_{i1}\n# inputs are in order of the creation/annilation operators\nfunction V_int(k_coords_f1, k_coords_f2, k_coords_i2, k_coords_i1, cf1=1, cf2=1, ci2=1, ci1=1)\n    # k_coords_* are tuples (k1, k2)\n    # each tuple element is either the momentum (when Gk=0) or the ratio of momentum to Gk (when Gk!=0)\n    # Your interaction potential here\n    return 1.0 + 0.0im  # Simple constant interaction will induce no interaction term because of Fermion exchange. \nend\n\n# Create parameter structure with keywords\npara = EDPara(k_list=k_list, Gk=Gk, Nc_hopping=Nc_hopping, Nc_conserve=Nc_conserve, H_onebody=H0, V_int=V_int)\n\n# Generate momentum subspaces for a system of 4 electrons in the first (and only) conserved component\nsubspaces, subspace_k1, subspace_k2 = ED_momentum_subspaces(para, (4,))\n\n# Generate Scatter lists\nscat_list1 = ED_sortedScatterList_onebody(para)\nscat_list2 = ED_sortedScatterList_twobody(para)\n\n# Solve the first momentum block for the 5 lowest eigenenergies\nenergies, eigenvectors = EDsolve(subspaces[1], scat_list1, scat_list2; N=5)\n\nprintln(\"Total momentum: (\", subspace_k1[1], \", \",  subspace_k2[1],\")  Ground state energy: \", energies[1])","category":"page"},{"location":"#API-Reference","page":"Home","title":"API Reference","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The public API is organized into several categories, reflecting the typical workflow.","category":"page"},{"location":"#Core-Types-(from-EDCore.jl)","page":"Home","title":"Core Types (from EDCore.jl)","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"MBS64{bits}: Represents a many-body state using bit encoding.\nHilbertSubspace: A container for a list of basis states (MBS64) that form a subspace.\nMBS64Vector: Represents an eigenvector, associating a raw vector with its HilbertSubspace.\nScatter{N}: Represents an N-body operator term.\nMBOperator: A collection of Scatter terms that defines a full many-body operator like the Hamiltonian.","category":"page"},{"location":"#System-Preparation","page":"Home","title":"System Preparation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"EDPara: A struct that holds all parameters for a calculation (k-list, interaction functions, etc.).\nED_momentum_subspaces: Generates the basis states, automatically partitioning them into HilbertSubspace objects based on total momentum.\nED_sortedScatterList_onebody: Creates the one-body part of the Hamiltonian as a list of Scatter{1} terms.\nED_sortedScatterList_twobody: Creates the two-body part of the Hamiltonian as a list of Scatter{2} terms.","category":"page"},{"location":"#Eigensolver","page":"Home","title":"Eigensolver","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"EDsolve: The main function to find the lowest eigenvalues and eigenvectors of a Hamiltonian within a given subspace. Supports both sparse matrix and matrix-free (LinearMap) methods.","category":"page"},{"location":"#Analysis","page":"Home","title":"Analysis","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Entanglement Spectrum:\nPES_1rdm, PES_MomtBlocks, PES_MomtBlock_rdm: Functions for calculating the particle entanglement spectrum.\nOES_NumMomtBlocks, OES_NumMomtBlock_coef: Functions for calculating the orbital entanglement spectrum.\nTopological Properties:\nED_connection_step, ED_connection_gaugefixing!: Functions for calculating the many-body Berry connection, used to find topological invariants like the Chern number.\nExpectation Values:\nED_bracket, ED_bracket_threaded: Low-level functions to compute the expectation value <ψ₁|O|ψ₂>.","category":"page"},{"location":"#Multi-Component-Systems","page":"Home","title":"Multi-Component Systems","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package supports systems with multiple components:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Conserved components\nNon-conserved components (also called hopping components in the code because usually there're hopping terms between them)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Using conserved components allows you to assign the particle number of each component when generating many-body state(mbs) list. The package will not check if the particle number is really conserved when generating Scatter list from given one-body term and two-body interaction. However, if a Scatter term scatters a mbs state outside the provided mbs list, the EDsolve() function will throw a \"NonConserved\" error.","category":"page"},{"location":"#Performance","page":"Home","title":"Performance","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package is optimized for performance:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Memory efficiency: Bit encoding and sparse matrix methods\nParallel processing: Multi-threaded when generating sparse Hamiltonian matrix.\nBlock diagonalization: Significantly reduced matrix sizes","category":"page"},{"location":"","page":"Home","title":"Home","text":"Typical performance explodes exponentially with system size and particle number.","category":"page"},{"location":"#Examples","page":"Home","title":"Examples","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package includes example notebooks about ED calculation on Landau levels.","category":"page"},{"location":"#License","page":"Home","title":"License","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package is licensed under the MIT License - see the LICENSE file for details.","category":"page"},{"location":"#Citation","page":"Home","title":"Citation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you use this package in your research, you might cite:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@software{MomentumED.jl,\n  author = {Zou, Bo},\n  title = {{MomentumED.jl}: A Julia Package for Exact Diagonalization in Momentum Basis},\n  year = {2025},\n  publisher = {GitHub},\n  journal = {GitHub repository},\n  howpublished = {\\url{https://github.com/Zou-Bo/MomentumED.jl}}\n}","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"This documentation is organized into two main parts, corresponding to the two packages in this repository:","category":"page"},{"location":"","page":"Home","title":"Home","text":"EDCore.jl: Contains the documentation for the low-level, generic building blocks of the exact diagonalization framework. This includes tutorials, manuals, and API references for the core data structures and their algebra.\nMomentumED.jl: Contains the documentation for the high-level functionalities specific to momentum-conserved systems. This section will provide guides and API references for setting up calculations, solving for eigenstates, and performing analyses within the momentum-space formalism.","category":"page"},{"location":"MomentumED/manual/#Manual","page":"Manual","title":"Manual","text":"","category":"section"},{"location":"MomentumED/manual/","page":"Manual","title":"Manual","text":"(Content to be added)","category":"page"}]
}
