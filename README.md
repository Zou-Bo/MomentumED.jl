# MomentumED.jl

[![CI](https://github.com/Zou-Bo/MomentumED.jl/workflows/CI/badge.svg)](https://github.com/Zou-Bo/MomentumED.jl/actions/workflows/CI.yml)
[![Documentation](https://img.shields.io/badge/docs-stable-blue.svg)](https://Zou-Bo.github.io/MomentumED.jl/stable)
[![Documentation](https://img.shields.io/badge/docs-dev-blue.svg)](https://Zou-Bo.github.io/MomentumED.jl/dev)
[![Code Style](https://img.shields.io/badge/code%20style-blue-4495d1.svg)](https://github.com/JuliaFormatter/JuliaFormatter.jl)
[![License](https://img.shields.io/badge/license-MIT-green.svg)](LICENSE)

A Julia package for momentum-conserved exact diagonalization of quantum many-body systems.

## Overview

This package provides ideal tools for exact diagonalization of 2D quantum many-body systems in momentum space. The Hamiltonian is Hermitian, momentum-conserved. Additional component index are allowed. 

This package provides types MBS64{bits} and Scattering{N} for easy manipulation, a eigensolver that warps solver in KrylovKit.jl and requires inputs (Vector{MBS64{bits}}, Vector{Scattering{1}}, Vector{Scattering{2}}), and a series of problem-initiating functions that converts standard many-body problems into the desired inputs of eigensolver. These functions are made with the assumption that the interaction is symmetric in switching the two vertices; if you are doing a specific problem that fails to fit in this assumption, consider making your dedicated initiating process.

This package also provide many-body state analysis methods to compute one-body reduced density matrix, many-body connection and many-body Chern number (NTW invariant), and (in development) reduced density matrix, entanglement entropy.

To do list: 
functions: mapping approach, scatter term in Hamiltonian with three or higher vertices, entanglement entropy
saving memory: mapping approach, choice for Float32 or Float16, temparary file saving, other ways of generating mbs lists of momentum blocks

The documentations are generated by AI, and I'm trying to make revisions now, but this page is safe.


## Features

- **Momentum Block Division**: Exploits translational symmetry for computational efficiency
- **Multi-Component Systems**: Support for both conserved and non-conserved components
- **Flexible Interactions**: Custom one-body and two-body interaction functions
- **Sparse Matrix Methods**: Efficient Hamiltonian construction using KrylovKit
- **Entanglement Analysis**: Built-in tools for entanglement entropy calculations
- **Topological Tools**: Berry connection calculations for topological invariants

## Installation

```julia
using Pkg
Pkg.add(url="https://github.com/Zou-Bo/MomentumED.jl")
```

## Quick Start

```julia
using MomentumED

# Define k-mesh for 2D system
k_list = [0 1 2 0 1 2 0 1 2 0 1 2 0 1 2;
          0 0 0 1 1 1 2 2 2 3 3 3 4 4 4]
Gk = (3, 5)

# Example system with one compotent
Nc_hopping = 1 # default number if not being configured explcitly
Nc_conserved = 1 # default number if not being configured explcitly

# Define one-body Hamiltonian (4-dim array)
H0 = ComplexF64[ #= Your Hamiltonian elements here =# 
  cospi(2 * k_list[1, k] / Gk[1]) + cospi(2 * k_list[2, k] / Gk[2]) # Simple band dispersion
  for ch_out in 1:Nc_hopping, ch_in in 1:Nc_hopping, cc in 1:Nc_conserved, k in axes(k_list, 2)
]

# Define interaction function, giving the amplitude before c†_{f1} c†_{f2} c_{i2} c_{i1}
# inputs are in order of the creation/annilation operators
function V_int(k_coords_f1, k_coords_f2, k_coords_i2, k_coords_i1, cf1=1, cf2=1, ci2=1, ci1=1)
    # k_coords_* are tuples (k1, k2)
    # each element is either the momentum (when Gk=0) or the ratio of momentum to Gk (when Gk!=0)
    # Your interaction potential here
    return 1.0 + 0.0im  # Simple constant interaction will induce no interaction term because of Fermion exchange. 
end

# Create parameter structure with keywords
para = EDPara(k_list=k_list, Gk=Gk, Nc_hopping=Nc_hopping, Nc_conserve=Nc_conserve, H_onebody=H0, V_int=V_int)

# Generate many-body states for 4 particles
mbs_list = ED_mbslist(para, 4)

# Divide into momentum blocks
blocks, block_k1, block_k2, k0number = ED_momentum_block_division(para, mbs_list)

# Generate scattering lists
scat_list1 = ED_sortedScatteringList_onebody(para)
scat_list2 = ED_sortedScatteringList_twobody(para)

# Solve first momentum block with 5 lowest eigenenergies
energies, eigenvectors = EDsolve(blocks[1], scat_list1, scat_list2, 5)

println("Ground state energy: ", energies[1])
```

## API Reference

### Core Data Structures

- **MBS64{bits}**: Many-body state representation using bit encoding in a UInt64
- **Scattering{N}**: Hamiltonian term representation: usually N=1 or 2 for one-/two-body "scattering" terms
- **EDPara**: Central parameter container for standard system configuration

### Main Functions

- **ED_mbslist()**: Generate many-body states for given particle number of each conserved component
- **ED_momentum_block_division()**: Divide Hilbert space into momentum blocks
- **ED_sortedScatteringList_onebody()**: Generate one-body scattering terms
- **ED_sortedScatteringList_twobody()**: Generate two-body scattering terms
- **EDsolve()**: Solve eigenvalue problem for momentum block using KrylovKit.jl
- **ED_etg_entropy()**: Calculate entanglement entropy
- **ED_connection_integral()**: Calculate many-body connection

### Multi-Component Systems

The package supports systems with multiple components:
- Conserved components
- Non-conserved components (also called hopping components in the code because usually there're hopping terms between them)

Using conserved components allows you to assign the particle number of each component when generating many-body state(mbs) list. The package will not check if the particle number is really conserved when generating scattering list from given one-body term and two-body interaction. However, if a scattering term scatters a mbs state outside the provided mbs list, the EDsolve() function will throw a "NonConserved" error.

## Performance

The package is optimized for performance:
- **Memory efficiency**: Bit encoding and sparse matrix methods
- **Parallel processing**: Multi-threaded when generating sparse Hamiltonian matrix.
- **Block diagonalization**: Significantly reduced matrix sizes

Typical performance explodes exponentially with system size and particle number.

## Examples

The package includes example notebooks:
- `examples/example1_FQH_Laughlin.ipynb`: Single-layer FQH system at filling factor 1/3
- `examples/example2_BilayerFQH_Halperin.ipynb`: Bilayer FQH system (3,3,1) Halperin state

## Documentation

Comprehensive documentation is available at:
- [Documentation](https://Zou-Bo.github.io/MomentumED.jl/stable) (In construction)

## Contribution
Let me know if you have any problems in using the package or find bugs.

## License

This package is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## Citation

If you use this package in your research, you might cite:

```bibtex
@software{MomentumED.jl,
  author = {Zou, Bo},
  title = {{MomentumED.jl}: A Julia Package for Exact Diagonalization in Momentum Basis},
  year = {2025},
  publisher = {GitHub},
  journal = {GitHub repository},
  howpublished = {\url{https://github.com/Zou-Bo/MomentumED.jl}}
}
```